<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关闭textarea的拼写检查]]></title>
    <url>%2F2019%2F09%2F06%2Ftextarea%E6%8B%BC%E5%86%99%E6%A3%80%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[最近使用textarea标签发现下面这个问题, 一顿Google最后解决,现在把解决方法做个记录。 解决方法：12&lt;!-- 添加 spellcheck="false" 属性 --&gt;&lt;textarea class="form-control share-text" rows="3" spellcheck="false" &gt;&lt;/textarea&gt;]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>textarea</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git subtree 的使用]]></title>
    <url>%2F2019%2F06%2F12%2Fsubtree%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[git subtree的主要命令有： 123456git subtree add --prefix=&lt;prefix&gt; &lt;commit&gt;git subtree add --prefix=&lt;prefix&gt; &lt;repository&gt; &lt;ref&gt;git subtree pull --prefix=&lt;prefix&gt; &lt;repository&gt; &lt;ref&gt;git subtree push --prefix=&lt;prefix&gt; &lt;repository&gt; &lt;ref&gt;git subtree merge --prefix=&lt;prefix&gt; &lt;commit&gt;git subtree split --prefix=&lt;prefix&gt; [OPTIONS] [&lt;commit&gt;] 准备我们先准备一个仓库叫Photo，一个仓库叫libPNG，然后我们希望把libPNG作为Photo的子仓库。Photo的路径为https://github.com/fanhang64/Photo.git，仓库里的文件有： 1234567Photo | |-- .gitignore |-- Photo.c |-- Photo.h |-- main.c \-- README.rst libPNG的路径为https://github.com/fanhang64/libPNG.git，仓库里的文件有： 1234567libpng | |-- libpng.c |-- libpng.h |-- README.rst |--test.c |--test.h 以下操作均位于父仓库的根目录中。 在父仓库中新增子仓库我们执行以下命令把libpng添加到Photo中： 1git subtree add --prefix=sub/libpng https://github.com/fanhang64/libpng.git master --squash (--squash参数表示不拉取历史信息，而只生成一条commit信息。) 执行git status可以看到提示新增两条commit： git log查看详细修改： 执行git push把修改推送到远端Photo仓库，现在本地仓库与远端仓库的目录结构为： 12345678910111213141516Photo | |-- sub/ | | | \--libpng/ | | | |-- libpng.c | |-- libpng.h | \-- README.rst | |-- test.c | |-- test.h | |-- Photo.c |-- Photo.h |-- main.c \-- README.rst 注意: 现在的Photo仓库对于其他项目人员来说，可以不需要知道libpng是一个子仓库。什么意思呢？当你git clone或者git pull的时候，你拉取到的是整个Photo(包括libpng在内，libpng就相当于Photo里的一个普通目录)；当你修改了libpng里的内容后执行git push，你将会把修改push到Photo上。也就是说Photo仓库下的libpng与其他文件无异。 从源仓库拉取更新如果源libpng仓库更新了，Photo里的libpng如何拉取更新？使用git subtree pull，例如： 1git subtree pull --prefix=sub/libpng https://github.com/fanhang64/libpng.git master --squash 推送修改到源仓库如果在Photo仓库里修改了libpng，然后想把这个修改推送到源libpng仓库呢？使用git subtree push，例如： 1git subtree push --prefix=sub/libpng https://github.com/fanhang64/libPNG.git master 简化git subtree命令我们已经知道了git subtree 的命令的基本用法，但是上述几个命令还是显得有点复杂，特别是子仓库的源仓库地址，特别不方便记忆。这里我们把子仓库的地址作为一个remote，方便记忆： 1git remote add -f libpng https://github.com/fanhang64/libPNG.git 然后可以这样来使用git subtree命令： 123git subtree add --prefix=sub/libpng libpng master --squashgit subtree pull --prefix=sub/libpng libpng master --squashgit subtree push --prefix=sub/libpng libpng master 参考链接： https://segmentfault.com/a/1190000012002151]]></content>
      <categories>
        <category>git相关</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>subtree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言正确使用extern关键字]]></title>
    <url>%2F2019%2F05%2F23%2FC%E8%AF%AD%E8%A8%80%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8extern%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[利用关键字extern，可以在一个文件中引用另一个文件中定义的变量或者函数，下面就结合具体的实例，分类说明一下。 一、引用同一个文件中的变量1234567891011121314151617#include&lt;stdio.h&gt;int func();int main()&#123; func(); printf("%d",num); return 0;&#125;int num = 3;int func()&#123; printf("%d\n",num);&#125; 如果按照这个顺序，变量 num在main函数的后边进行声明和初始化的话，那么在main函数中是不能直接引用num这个变量的，因为当编译器编译到这一句话的时候，找不到num这个变量的声明，但是在func函数中是可以正常使用，因为func对num的调用是发生在num的声明和初始化之后。 问题： 如果我不想改变num的声明的位置，但是想在main函数中直接使用num这个变量，怎么办呢？ 可以使用extern这个关键字。像下面这一段代码，利用extern关键字先声明一下num变量，告诉编译器num这个变量是存在的，但是不是在这之前声明的，你到别的地方找找吧，果然，这样就可以顺利通过编译啦。但是你要是想欺骗编译器也是不行的，比如你声明了extern int num；但是在后面却没有真正的给出num变量的声明，那么编译器去别的地方找了，但是没找到还是不行的。 下面的程序就是利用extern关键字，使用在后边定义的变量。 123456789101112131415161718#include&lt;stdio.h&gt;int func();int main()&#123; func(); // 3 extern int num; printf("%d",num); // 3 return 0;&#125;int num = 3;int func()&#123; printf("%d\n",num);&#125; 二、引用另一个文件中的变量如果extern这个关键字就这点功能，那么这个关键字就显得多余了，因为上边的程序可以通过将num变量在main函数的上边声明，使得在main函数中也可以使用。extern这个关键字的真正的作用是引用不在同一个文件中的变量或者函数。 实例： 12345678910111213141516171819202122// 在main.c中#include&lt;stdio.h&gt;int main()&#123; extern int num; // 引用b.c中的num printf("%d",num); return 0;&#125;// 在b.c文件中#include&lt;stdio.h&gt;int num = 5;void func()&#123; printf("fun in b.c");&#125; 例如，这里b.c中定义了一个变量num，如果main.c中想要引用这个变量，那么可以使用extern这个关键字，注意这里能成功引用的原因是，num这个关键字在b.c中是一个全局变量，也就是说只有当一个变量是一个全局变量时，extern变量才会起作用，向下面这样是不行的。 实例： 1234567891011121314151617181920// 在mian.c中#include&lt;stdio.h&gt;int main()&#123; extern int num; // ok 声明时候不会报错 printf("%d",num); // error return 0;&#125;// 在b.c中#include&lt;stdio.h&gt;void func()&#123; int num = 5; // 局部变量 printf("fun in b.c");&#125; 另外，extern关键字只需要指明类型和变量名就行了，不能再重新赋值，初始化需要在原文件所在处进行，如果不进行初始化的话，全局变量会被编译器自动初始化为0。下面像这种写法是不行的，extern int num=4; ，但是在声明之后就可以使用变量名进行修改了，像这样： 123456789#include&lt;stdio.h&gt;int main()&#123; extern int num; num=1; // ok printf("%d",num); return 0;&#125; 如果不想这个变量被修改可以使用const关键字进行修饰，写法如下： 1234567891011121314151617181920// 在mian.c中#include&lt;stdio.h&gt;int main()&#123; extern const int num; printf("%d",num); return 0;&#125;// 在b.c中#include&lt;stdio.h&gt;const int num=5;void func()&#123; printf("fun in b.c");&#125; 使用include将另一个文件全部包含进去可以引用另一个文件中的变量，但是这样做的结果就是，被包含的文件中的所有的变量和方法都可以被这个文件使用，这样就变得不安全，如果只是希望一个文件使用另一个文件中的某个变量还是使用extern关键字更好（注意：没有include &quot;b.c&quot;文件）。 三、引用另一个文件中的函数extern 关键字除了引用另一个文件中的变量外，还可以引用另一个文件中的函数，引用方法和引用变量相似。 1234567891011121314151617181920// 在mian.c中#include&lt;stdio.h&gt;int main()&#123; extern void func(); func(); return 0;&#125;// 在b.c中#include&lt;stdio.h&gt;const int num=5;void func()&#123; printf("fun in b.c");&#125; 这里main函数中引用了b.c中的函数func。因为所有的函数都是全局的，所以对函数的extern用法和对全局变量的修饰基本相同，需要注意的就是，需要指明返回值的类型和参数。 文章转自网络，查看原文章，请访问：http://blog.csdn.net/xingjiarong/article/details/47656339]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[numpy常用数组操作函数]]></title>
    <url>%2F2019%2F05%2F08%2Fnumpy%E5%B8%B8%E7%94%A8%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0-md%2F</url>
    <content type="text"><![CDATA[Numpy 数组操作函数Numpy 中包含了一些函数用于处理数组，大概可分为以下几类： 修改数组形状 翻转数组 连接数组 分割数组 数组元素的添加与删除 修改数组形状1234567891011121314151617181920# numpy.reshape(shape, order='C') # 参数: order：'C' -- 按行，'F' -- 按列，'A' -- 原顺序，'k' -- 元素在内存中的出现顺序。&gt;&gt; arr = np.arange(12).reshape((3, 4))# ndarray.flatten(order='C')# 返回一份数组拷贝,并返回一维数组# 参数: &gt;&gt; arr.flatten()array([ 1, 3, 5, 4, 6, 8, 7, 9, 11, 10, 12, 14])# numpy.ravel([order])# 展平的数组元素，返回一维数组拷贝,不影响原数组。&gt;&gt; arr.ravel()array([ 1, 3, 5, 4, 6, 8, 7, 9, 11, 10, 12, 14])&gt;&gt; arrarray([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]]) 翻转数组函数12345678910111213# np.transpose(a, axes=None) # 函数用于对换数组的维度&gt;&gt; arr = np.arange(12).reshape(3, 4)&gt;&gt; print(arr)&gt;&gt; print(np.transpose(arr))&gt;&gt; print(arr.T) # 转置矩阵(同上)[[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11]][[ 0 4 8] [ 1 5 9] [ 2 6 10] [ 3 7 11]] 连接数组12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970# np.concatenate((a1, a2, ...), axis) # 数用于沿指定轴连接相同形状的两个或多个数组&gt;&gt; arr = np.array([[1, 2], [3, 4]])&gt;&gt; arr2 = np.array([[5 ,6], [7, 8]])&gt;&gt; print(arr, arr2)&gt;&gt; print(np.concatenate((arr, arr2))) # 沿着行连接&gt;&gt; print(np.concatenate((arr, arr2), axis=1) # 沿着列链接[[1 2] [3 4]] [[5 6] [7 8]][[1 2] [3 4] [5 6] [7 8]][[1 2 5 6] [3 4 7 8]] # np.stack(arrays, axis=0) # 函数用于沿指定轴堆积数组序列&gt;&gt; arr = np.array([[1, 2], [3, 4]])&gt;&gt; arr2 = np.array([[5, 6], [7, 8]])&gt;&gt; print(np.stack((arr, arr2))) # 沿着行堆积数组, 二维堆成三维&gt;&gt; print(np.stack((arr, arr2), axis=1)) # 沿着列堆积数组[[[1 2] [3 4]] [[5 6] [7 8]]][[[1 2] [5 6]] [[3 4] [7 8]]]# np.hstack() # 通过水平堆积来生成数组(横向)&gt;&gt; a = np.array((1,2,3))&gt;&gt; b = np.array((2,3,4))&gt;&gt; np.hstack((a,b))array([1, 2, 3, 2, 3, 4])&gt;&gt; a = np.array([ [1], [2], [3]])&gt;&gt; b = np.array([ [2], [3], [4]])&gt;&gt; np.hstack((a,b)) # 水平扩展(a的[1]与b的[2])array([[1, 2], [2, 3], [3, 4]])# np.vstack() # 通过竖直堆积生成数组&gt;&gt; a = np.array([ [1, 2], [3, 4]])&gt;&gt; b = np.array([ [5, 6], [7, 8]])&gt;&gt; print(np.vstack((a, b)))[[1 2] [3 4] [5 6] [7 8]] 分割数组12345678910111213141516171819202122232425262728293031323334353637# np.split(arr, indices_or_sections, axis=0) # 函数沿特定的轴将数组分割为子数组&gt;&gt; a = np.arange(9)&gt;&gt; np.split(a, 1)[array([0, 1, 2, 3, 4, 5, 6, 7, 8])]&gt;&gt; np.split(a, 3) # 将数组分为三个大小相等的子数组[array([0, 1, 2]), array([3, 4, 5]), array([6, 7, 8])]&gt;&gt; np.split(a, [4, 7]) # 将数组在一维数组中表明的位置分割[array([0, 1, 2, 3]), array([4, 5, 6]), array([7, 8])]# np.hsplit(arr, indices_or_sections) 函数用于水平分割数组，通过指定要返回的相同形状的数组数量来拆分原数组。&gt;&gt; x = np.arange(16.0).reshape(4, 4)&gt;&gt; print(x)array([[ 0., 1., 2., 3.], [ 4., 5., 6., 7.], [ 8., 9., 10., 11.], [12., 13., 14., 15.]])&gt;&gt; np.hsplit(x, 2)[array([[ 0., 1.], [ 4., 5.], [ 8., 9.], [12., 13.]]), array([[ 2., 3.], [ 6., 7.], [10., 11.], [14., 15.]])]&gt;&gt; np.hsplit(x, np.array([1, 2]))[array([[ 0.], [ 4.], [ 8.], [12.]]), array([[ 1.], [ 5.], [ 9.], [13.]]), array([[ 2., 3.], [ 6., 7.], [10., 11.], [14., 15.]])] 参考文档:https://www.runoob.com/numpy/numpy-array-manipulation.html]]></content>
      <categories>
        <category>数据分析与机器学习</category>
      </categories>
      <tags>
        <tag>数据</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo添加访问量统计]]></title>
    <url>%2F2019%2F05%2F07%2Fhexo%E6%B7%BB%E5%8A%A0%E8%AE%BF%E9%97%AE%E9%87%8F%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[使用的是不蒜子提供的阅读统计功能，hexo主题是next。 步骤如下:1) 添加是否开启统计功能的配置 找到next主题的配置文件themes/next/_config.yml，找到原来的footer字段，加入一个配置，这里我们叫它counter吧，即12footer: counter: true 注意:hexo博客解决不蒜子统计无法显示问题, 这里引用官网 因七牛强制过期『dn-lbstatics.qbox.me』域名，与客服沟通无果，只能更换域名到『busuanzi.ibruce.info』！ 2) 修改next主题的模板文件由于是把访问量统计放在网页的footer，所以我们需要修改的模板文件是theme/next/layout/_partials/footer.swig。我们在合适的位置加入：123456789&#123;% if theme.footer.counter %&#125; &lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; &lt;span id=&quot;busuanzi_container_site_pv&quot;&gt;总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt; &lt;span id=&quot;busuanzi_container_site_uv&quot;&gt;总访客&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人&lt;/span&gt; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;&#123;% endif %&#125;]]></content>
      <categories>
        <category>hexo的使用</category>
      </categories>
      <tags>
        <tag>hexo的入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[numpy的基本使用]]></title>
    <url>%2F2019%2F05%2F05%2Fnumpy%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[NumPy的基本使用Numpy是一个开源的Python科学计算库，它是Python进行科学计算的基础库，许多著名的科学计算库如Pandas，Scikit-learn等都要用到Numpy库的一些功能。NumPy根据BSD许可证授权，只需很少的限制即可重复使用。 基础知识NumPy是一个元素表(通常是数字), 这些元素都具有相同的类型，由正整数元组索引的多维数组。在NumPy维度中称为轴。 例如: 在一个3D空间中[1, 2, 1] 有一个轴, 这个轴里面有三个元素, 因此它的长度就是3。如下所示, 这个数组有2个轴, 第一个轴长度为2 即[1., 0., 0.]和[0., 1., 2.] , 第二个轴长度为3(三个元素)。 12[[ 1., 0., 0.], [ 0., 1., 2.]] NumPy的类型称为ndarray, 即数组。请注意，numpy.array与标准Python库类array.array不同。如下是常用属性: ndarray.ndim : 数组轴的个数(维度)。 ndarray.shape : 数组的维度, 返回一个整数的元组, 表示这个维度数组的大小, 对于一个n行和m列的矩阵，shape将为（n，m）。注意，shape这个元组的长度是轴的数量即ndim。 ndarray.size : 数组所有元素的个数。 ndarray.dtype : 描述数组元素类型。 ndarray.itemsize : 数组中每个元素的字节大小。 ndarray.T : 数组的转置。 ndarray.real : 输出数组包含元素的实部。 ndarray.imag : 输出数组包含元素的虚部分。 Example: 1234567891011121314151617181920212223242526272829import numpy as np# np.arange([start,] stop[, step,], dtype=None)arr = np.arange(3)print(arr)# array([0, 1, 2])arr = np.arange(3.0) # 与python标准库函数range不同, arange可以传float类型参数print(arr)# array([0., 1., 2.])arr = np.arange(3, 7)print(arr)# array([3, 4, 5, 6])arr = np.arange(15).reshape(3, 5)# array([[ 0, 1, 2, 3, 4],# [ 5, 6, 7, 8, 9],# [10, 11, 12, 13, 14]])print(arr.shape) # (3, 5)print(arr.ndim) # 2print(arr.dtype.name) # int64print(arr.itemsize) # 8print(arr.size) # 15print(type(arr)) # &lt;type 'numpy.ndarray'&gt;arr = np.array([1,2, 3])print(type(arr)) # &lt;type 'numpy.ndarray'&gt; 创建数组1) 通过列表或元组创建 最终数组的类型取决于序列中元素的类型 1234567891011121314import numpy as nparr = np.array([2, 3, 4])print(arr) # array([2, 3, 4])print(arr.dtype) # dtype('int64')arr = np.array([1.2, 2.3, 3.4])print(arr.dtype) # dtype('float64')# 二维数组 (2*3)arr2 = np.array([[1,2,4], [3,4,5]])print(arr2)# array([[1, 2, 4],# [3, 4, 5]]) 2) 通过np.arrange()等方法创建 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import numpy as nparr = np.arange(10, 30, 5)print(arr) # array([10, 15, 20, 25])arr = np.zeros((3,4))print(arr) # 创建一个全为0的数组# array([[ 0., 0., 0., 0.],# [ 0., 0., 0., 0.],# [ 0., 0., 0., 0.]])arr = np.ones((2, 3, 4), dtype=np.int16) # 可以指定参数print(arr) # 创建一个全为1的数组# array([[[ 1, 1, 1, 1],# [ 1, 1, 1, 1],# [ 1, 1, 1, 1]],# [[ 1, 1, 1, 1],# [ 1, 1, 1, 1],# [ 1, 1, 1, 1]]], dtype=int16)# linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None) # 返回在start到stop之间均匀分布的num个数字，可以选择是否包括stop. retstep表示是否返回步长.arr = np.linspace(1, 5, 5, True)print(arr) # array([ 1., 2., 3., 4., 5.])arr = np.linspace(1, 5, 5, False)print(arr) # array([ 1. , 1.8, 2.6, 3.4, 4.2])# numpy.eye(N, M=None, k=0, dtype=&lt;class 'float'&gt;, order='C')# 返回一个二维数组，其中对角线为1，其他位置为零。k：对角线的索引：0（默认值）是主对角线，正值指的是上对角线，负值指的是下对角线。arr = np.eye(2, dtype=int)print(arr)# array([[1, 0],# [0, 1]])arr = np.eye(3, k=1)print(arr)# array([[0., 1., 0.],# [0., 0., 1.],# [0., 0., 0.]])# ones_like，zeros_like，empty_like函数# 返回一个与给定数组具有相同形状和类型的数组。x = np.arange(6)x = x.reshape((2, 3))print(x)# array([[0, 1, 2],# [3, 4, 5]])arr = np.ones_like(x) # zeros_like，empty_like雷同print(arr)# array([[1, 1, 1],# [1, 1, 1]]) 基本操作Example: 1234567891011121314151617181920212223242526272829303132333435363738394041import numpy as npa = np.array([20, 30, 40, 50])b = np.arange(4)print(b) # array([0, 1, 2, 3])c = a - bprint(c) # array([20, 29, 38, 47])d = b ** 2 print(d) # array([0, 1, 4, 9])e = 10 * np.sin(a)print(e) # array([ 9.12945251, -9.88031624, 7.4511316 , -2.62374854])f = a &lt; 35print(f) # array([ True, True, False, False])# 矩阵(数组)*点乘和@叉乘A = np.array([[1,1], [0,1]])B = np.array([[2,0], [3,4]])print(A * B)# array([[2, 0],# [0, 4]])print(A @ B) # 同 A.dot(B)# array([[5, 4],# [3, 4]])# 重设形状# np.reshape(shape, order='C')print(np.arange(6).reshape((3, 2)))# [[0 1]# [2 3]# [4 5]]# 数组展开# np.ravel([order]) # order 表示变换时的读取顺序，默认是Order='C' 按照行依次读取，当 order='F' 时，可以按列依次读取arr = np.arange(6).reshape((3, 2))print(arr.ravel()) # array([0, 1, 2, 3, 4, 5])print(arr.ravel('F') # array([0, 2, 4, 1, 3, 5]) 注意: 大小相等的数组之间的任何算术运算都会将运算应用到元素级 数组与标量的算术运算会将标量值传播到各个元素 索引, 切片, 迭代(1) 一维数组操作一维数组可以进行索引，切片和迭代操作，就像列表和其他Python序列一样。 Example: 1234567891011import numpy as npa = np.arange(10) ** 3print(a) # array([ 0, 1, 8, 27, 64, 125, 216, 343, 512, 729])print(a[2:5]) # array([8, 27, 64])a[:6:2] = 1000 # 等同于a[0:6:2] = -1000 即 0 2 4 置为0a[::-1] # array([729, 512, 343, 216, 125, -1000, 27, -1000, 1, -1000])for i in a: print(i) # 0 1 ... (2) 多维数组操作Example: 123456789101112131415161718192021222324252627&gt;&gt; def f(x, y):... return 10 * x + y&gt;&gt; arr = np.fromfunction(f, (5, 4), dtype=int)&gt;&gt; print(arr)array([[ 0, 1, 2, 3], [10, 11, 12, 13], [20, 21, 22, 23], [30, 31, 32, 33], [40, 41, 42, 43]])&gt;&gt; b[1, 3] # b[行索引, 列索引]13&gt;&gt; b[0:5, 1] # 每一行的第1列array([ 1, 11, 21, 31, 41])&gt;&gt; b[1:3, :] # 第1-2行的所有列array([[10, 11, 12, 13], [20, 21, 22, 23]])&gt;&gt; c = np.arange(12)&gt;&gt; print(c)[ 0 1 2 3 4 5 6 7 8 9 10 11]&gt;&gt; print(c[4]) # 4&gt;&gt; c.shape = (3, 4) # c变为2维数组&gt;&gt; print(c)[[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11]] 当提供的索引数少于轴数时，缺失的索引将被视为完整切片： 12&gt;&gt; b[-1] # 取最后一行,等同于b[-1,:]array([40, 41, 42, 43]) 针对第一个轴对多维数组进行迭代： 1234567891011121314151617&gt;&gt; for i in b:... print(i)[0 1 2 3][10 11 12 13][20 21 22 23][30 31 32 33][40 41 42 43]# 可以通过np.flat遍历每一个元素, flat属性返回一个迭代器, &gt;&gt;&gt; for i in b.flat:... print(i)012310... (3) 整数数组索引1234567891011121314151617181920212223242526272829303132333435363738394041424344&gt;&gt; import numpy as np&gt;&gt; arr = np.arange(1,10)&gt;&gt; print(arr)[1 2 3 4 5 6 7 8 9]&gt;&gt; arr[np.array([2, 2, -3, 7])] # 由值2，2，-3和7组成的索引数组相应地创建了一个长度为4的数组。array([3, 3, 7, 8])&gt;&gt; arr = np.arange(6).reshape((3, 2))&gt;&gt; print(arr)[[0 1] [2 3] [4 5]]&gt;&gt; arr2 = arr[[0,1]] # 获取0,1行的值&gt;&gt; print(arr2)[[0 1] [2 3]]# 下面这种情况，如果索引数组具有匹配的形状，并且索引数组的每个维都有一个索引数组，则结果数组具有与索引数组相同的形状，并且这些值对应于每个索引集的索引在索引数组中的位置。在此示例中，两个索引数组的第一个索引值为0，因此结果数组的第一个值为arr3[0,0]。下一个值是arr3[1,1]，最后一个是arr3[2,3]&gt;&gt; arr3 = np.arange(12).reshape(3, 4)&gt;&gt; print(arr3)[[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11]]&gt;&gt; arr3[[0,1,2], [0, 1, 3]][0 5 11]&gt;&gt; arr4 = arr3[[0,1,2], [1]] # 获取0,1行第1列的值, 尝试将它们广播到相同的形状，即取值arr3[0,1]，arr3[1, 1], arr3[2, 1]&gt;&gt; print(arr4)[1, 5, 9]&gt;&gt; arr = np.arange(12).reshape((4, 3))[[ 0 1 2] [ 3 4 5] [ 6 7 8] [ 9 10 11]]&gt;&gt; rows = np.array([[0,0], [3,3]])&gt;&gt; cols = np.array([[0,2], [0,2]])&gt;&gt; x = arr[rows, cols] # 取四个角元素&gt;&gt; print(x)[[ 0 2] [ 9 11]] (4) 布尔索引布尔数组的形状必须与被索引数组的初始维度相同，其中包含索引数组中所有对应于布尔数组中所有真实元素的元素。 Example: 123456789101112131415161718&gt;&gt; import numpy as np&gt;&gt; arr = np.arange(12).reshape(3, 4)&gt;&gt; print(arr)&gt;&gt; x = arr &gt; 7&gt;&gt; print(x)[[False False False False] [False False False False] [ True True True True]]&gt;&gt; arr[x] # 结果为一维数组array([ 8, 9, 10, 11])&gt;&gt; y = x[:, 1]&gt;&gt; print(y) # 所有行的第一列元素(广播)[False False True]&gt;&gt; arr[y] # 即取第2行, 0,1行为False不取array([[ 8, 9, 10, 11]]) 广播广播(Broadcast)是 numpy 对不同shape的数组进行数值计算的方式，对数组的算术运算通常是元素级别的。 如果两个数组 a 和 b 形状相同，即满足a.shape == b.shape，那么 a*b 的结果就是 a 与 b 数组对应位置的元素相乘。这要求维数相同，且各维度的长度相同。 123456import numpy as nparr1 = np.array([1, 2, 3])arr2 = np.arange(11, 14)arr = arr1 + arr2print(arr) # [12 14 16] 当执行操作的两个数组, shape不同时,会自动触发广播机制。 1234567891011&gt;&gt; import numpy as np&gt;&gt; arr2 = np.array([1, 2, 3])&gt;&gt; arr3 = np.arange(12).reshape((4, 3))&gt;&gt; arr = arr2 + arr3 # ==&gt; 等同于 arr2为[[1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3]]相加&gt;&gt; print(arr)[[ 1 3 5] [ 4 6 8] [ 7 9 11] [10 12 14]] 参考文档： https://www.numpy.org/devdocs/user/quickstart.html https://www.numpy.org.cn/user_guide/numpy_basics/indexing.html https://www.runoob.com/numpy/numpy-broadcast.html]]></content>
      <categories>
        <category>数据分析与机器学习</category>
      </categories>
      <tags>
        <tag>数据</tag>
      </tags>
  </entry>
</search>
