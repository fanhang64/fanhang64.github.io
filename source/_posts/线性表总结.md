---
title: 线性表总结.md
date: 2021-01-07 17:59:22
tags: 线性表 数据结构
categories: 数据结构与算法
---

1. 线性表是相同类型**数据元素**的有限序列，也是一种逻辑结构。
2. 线性表特点:存在唯一的一个被称为'第一个'的数据元素；存在唯一一个被称为'最后一个'的元素；除第一个元素，其余都有一个'前驱'，除最后一个，都有一个'后继'。
3. 题型:计算二维数组按行(列)优先方式存放，指定元素的起始地址
   ```
   例如:二维数组M[i][j]，每个元素长度为3字节，行下标0-7，列下标j从0-9，首地址为In,
   若按行优先存放，则M[7][6]的起始地址为In+(7*10+6)*3。
   若按列优先存放，则地址In+(6*8+7)*3
   ```
<!--more-->
   
4. 线性表的结构体定义
   ```
   #define maxsize 100
   
   # 顺序表定义
   int A[maxsize];
   int length;
   
   # 链表结构体定义(单链表；循环单链表，最后结点指向头结点)
   typedef struct LNode{
       int data;
       struct LNode *next;
   }LNode;
   
   # 双链表结构体定义
   typedef struct DLNode{
       int data;
       struct DLNode *prior;  // 指向前驱的指针
       struct DLNode *next;
   }DLNode;
   
   # 动态分配内存
   L.data = (ElemType *)malloc(sizeof(ElemType)*size);
   ```

### 顺序表-线性表顺序存储结构
1. 特点: 逻辑相邻，物理也相邻；随机访问。
2. 顺序表为空：L.length == 0
3. 顺序表满：L.length == Maxsize
4. 基本算法
   ```
   # (1) 查找算法
   for (i = 0; i < L.length; i++)
       if(L.data[i]==x)
          break；
    if (i<L.length)  // 如果没有找到，最后一次循环，i==L.length了
        return i；// 找到了
    else
        未找到
    
   # (2) 插入算法
   
   bool Sqlistinsert(SqList &L,int i,ElemType x) // 这里i取值从1至length+1
   {
      // 如果长度大于L.length+1时超过数组下标范围
      if (i > L.length+1 || L.length==Maxsize || i<1) {
          return false；
      }
      for(j = L.length; j > i-1;j--)
          L.data[j]=L.data[j-1]；
      L.data[i-1] = x；
      L.length++；
      return true；
   }
   
   # (3) 删除算法
   其中i的范围同上
   bool listDelete(SqlList &L,int i, ElemType &x){
       if (i < 1|| i > L.length||L.length==0){
           return false;
       }
       x = L.data[i-1];
       for(j=i; j<L.length;j++){
           L.data[j-1]=L.data[j];
       }
       L.length--;
       return true;
   }
   ```

5. 算法分析
   - 插入，删除时，时间复杂度为O(n)，在尾端插入，删除时时间复杂度为O(1)
   - 插入时平均移动次数，表长为n，若在任意结点后插入(任意结点前插入)，插入位置有n个，平均移动次数(1+n)/2；在任意位置插入，插入位置有n+1个位置，平均移动次数n/2
   - 删除时移动元素n-1/2

### 单链表
1. 特点：用指针表示数据之间的逻辑关系。(逻辑相近的元素，物理位置不一定相邻)
2. 带头结点单链表判空：L->next=NULL;单链表不空条件：L->next=NULL;
3. 基本算法
  ```
  # (1) 顺序访问所有元素
  void printvalue(Linklist &L){
    p = L->next;
    while (p !=NULL){
        visit(p->data);
        p = p->next;
    }
  }
  
  # (2) 查找元素x,找到返回地址
  Linist Find(Linklist L, ElemType x){
      p = L->next;
      wile (p != NULL){
          if (p.data == x) return p;
      }
      return NULL;
  }
  # (3) 查找元素，先到返回位序
  int Find(LinkList L,ElemType x){
      p = p->next;
      int i = 0;
      while (p!=NULL){
          i++;
          if (p->data==x){
              return i;
          }
          p = p->next;
      }
      return i;
  }
  # (4) 查找第i个位置
  Linklist Get(Linklist L, int i){ // i的取值从1开始
      p = p->next;
      j = 1;
      while (p!=NULL && j < i){
          p = p->next;
          j++;
      }
      if (p && j == i){
          return p;
      }
      return NULL;
  }
  # (5) 插入算法
  bool insertLit(Linklist &L, int i, ElemType x){  // 插入到第i的位置,例如插入到2位置，的指针应该指向1的元素位置
      p = L;
      j = 0;
      // 首先找到第i的元素(1--n)
      while(p && j < i-1){
          p = p->next;
          j++;
      }
      if(p && j== i-1){
          t = (Linklist)malloc(sizeof(LNode);
          t->data = x;
          t->next=p->net;
          p->next = t;
          return true;
      }
      return false;
  }
  # (6) 删除算法
  bool LinklistDelete(LinkList L, int i, ElemType &x){
      // 找到i-1的元素位置(从1开始)
      p = L;
      j = 0;
      while (p && j < i-1){
          p = p->next;
          j++;
      }
      if(p && j == i-1 && p->next){
          x = p->next->data;
          s = p->next;
          p->next = s->next;
          free(s);
          return true;
      }
      return false;
  }
  # (7) 链表创建
  void createLinkList(Linklist &L, int n){  // 尾插法插入n个元素
      L = (Linklist)malloc(sizeof(LNode);
      L->next = NULL;
      p = L;
      for(int i =0; i<n;i++){
          scanf(x);
          s = (Linklist)malloc(sizeof(LNode));
          s->data = x;
          s->next = p->next;
          p->next = s;
          p = s;
      }
  }
  // 头插法
  s = (Linklist)malloc(sizeof(LNode));
  s->data = x;
  s->next = L->next;
  L->next = s;
  
  # (8) 将两个有序链表合并为一个
  void merge(LinkList &La, linLinklist &Lb, Linklist &Lc){
      pa = La.next; pb =Lb.next;
      Lc = pc =La;  // La的头节点当做Lc的头节点
      while(pa && pb){
          if (pa->data <= pb->data){
              pc->next = pa;
              pc = pa;
              pa = pa->next;
          }else {
              pc-next = pb;
              pc = pb;
              pb = pb->next;
          }
      }
      pc->next = pa?pa:pb; // pa为空，则等于pb
      free(Lb);
  }
  ```

### 循环链表(单向循环链表)
1. 特点：最后一个结点的指针指向头结点
2. 循环链表空表：`L->next == L`
3. 判断表为的方法与单链表不同：`单链表是p==NULL；循环链表是p==L`。
4. 循环链表只设尾指针操作效率会更高。

### 双向循环链表
1. 特点：每个结点包含后继(next)和前驱(prior)，且两个方向又分别构成循环链表。
2. 双向循环链表判断空表条件(带头节点)：`L->next ==L &&L->prior==L`
3. 与单链表和循环链表区别：最大不同是前驱容易求得，可以向前遍历；
4. 判断表尾方法与循环链表相同：p == L
5. 双向循环链表每个指针都指向前或后一个结点，都不为空。
6. 插入和删除操作
   ```cpp
   # 在p之后插入s结点
   s->next = p->next;
   p->next->prior = s;
   s->prior = p;
   p->next = s;
   
   # 在p之前插入s
   s->prior = p->prior;
   p->prior->next = s;
   s->next = p;
   p->prior = s;
   
   # 删除p后继s
   s = p->next;
   p->next = s->next;
   s->next->prior = s->prior;
   free(s);
   
   # 删除p
   p->prior->next = p->next;
   p->next->prior = p->prior;
   free(p);
   ```
7. 为了方便插入和删除，可以使用**双链表**存放数据。

### 顺序表和链表比较
1. 顺序表元素在物理和逻辑上都相邻；链表在逻辑上相邻，物理上不一定。
2. 顺序表随机访问，取元素时O(1)；链表顺序访问，取元素时O(n)。
3. 顺序表插入，删除时需要移动O(n)；单链表插入，删除不用移动元素O(n)(用于查找位置)。
4. 需要反复插入，删除宜采用链表；反复提取，很少插入，删除，宜采用顺序表。
5. 链式存储比顺序存储能更方便的表示各种逻辑结构。

### 静态链表
1. 需要分配很大的连续空间，插入和删除不需要移动元素。
