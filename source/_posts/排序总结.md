---
title: 排序总结
date: 2021-01-07 18:13:21
tags: 
- 排序
- 快速排序
- 希尔排序
- 堆排序
categories: 数据结构与算法
---

1. 稳定性：如果存在重复关键字，原则排序算法时，要考虑稳定性。例如：50(a)在50(b)之前，排完序后扔在之前，说明稳定

### 插入类排序
#### 1) 直接插入
1. 将待排序记录，插入到已排好的有序序列中，重复n-1次
2. 代码
   ```C
      void insertSort(int a[], int n){  // 带排序数组在a，元素个数为n，从下标1开始存储
          int i,j;
          for(i=2;i<=n;i++){
              if(a[i] < a[i-1]){ // 如果是为正序，这里不执行。
                  a[0] = a[i];  // a[0]为哨兵
                  for(j=i-1;a[0]<a[j];--j){
                      a[j+1] = a[j];
                  }
                  a[j+1] = a[0];  // 找到插入位置，将暂存关键字插入
              }
          }
          
      }
   ```
<!--more-->
3. 例题
   > ![image](https://note.youdao.com/yws/api/personal/file/45214150543925a7729207ebc8bd5b0a?method=download&shareKey=d6cf23e227d13460e26c02b27a95d048&inline=true)
4. 分析
   > 1) 最坏情况，整个序列逆序的，此时时间复杂度为O(n^2)</br>
   > 2) 最好的情况，整个序列已经有序，内层循环不执行，则时间复杂度为O(n)。</br>
   > 3) 空间复杂度为O(1)</br>
   > 4) 一趟排序后，不能确定一个关键字到达最后位置。插入类排序共同特点</br>
   > 5) 一种稳定排序算法
   > 6) 直接插入最坏情况下，比较次数为n(n-1)/2，最好情况下为n-1

#### 2) 折半插入
1. 折半插入排序，通过折半查找法确定插入位置。
2. 基本条件：**序列已经有序**。
3. 例题
   > ![image](https://note.youdao.com/yws/api/personal/file/fc851c8a4bd12df84c782bb29b3bdfe9?method=download&shareKey=7c98ec6d04f8d0333fa092b17c70417c&inline=true)

4. 代码
   ```C
      void InsertSort(int a[],int n){
          int i,j,low,high,mid;
          for(i=2;i<=n;i++){ // 将a[2]至a[n]插入到前面已经排好序的序列
              a[0]=a[i];
              low = 1; high= i-1;
              while(low <= high){
                  mid = (low+high) / 2;
                  if(a[mid] > a[0]){
                      high = mid -1;
                  }else{
                      low =mid+1;
                  }
              }
              for(j=i-1;j>=high+1;--j){
                  a[j+1] = a[j];
              }
              a[j+1] = a[0];
          }
      }
   ```

5. 性能分析
   > 1) 平均时间复杂度O(n^2)</br>
   > 2) 稳定的插入排序</br>
   > 3) 关键字比较次数与初始序列无关。
   > 4) 只是比直接插入少了比较次数，约为O(nlogn)

#### 3) 希尔排序
1. 先将待排序序列分割成若干个子序列，分别进行直接插入排序，基本有序后，在整体进行直接插入排序。
2. 步骤：
   ```
      1) 按照增量d，将序列分成几个子序列。
      2) 对子序列排序(直接插入排序)
      3) 缩小增量d，重复1，2步，直到增量d=1
   ```
3. 代码
   ```c
      # 希尔排序
      void shellInsert(sqList &L, int dk){   // L顺序表，dk为增量
          for(i = dk+1;i≤L.length;++i){
              if(L.r[i].key<L.r[i-dk].key){  // 
                  L.r[0] = L.r[i];  // 暂存到L.r[0]
                  for(j=i-dk; j>0 && (L.r[0].key < L.r[j].key); j-=dk){  // 记录后移，寻找插入位置
                      L.r[j+dk] = L.r[j];
                  }
                  L.r[j+dk] = L.r[0];  // 插入到指定位置
              }
          }
       
       }
   ```
3. 例题
   > ![image](https://note.youdao.com/yws/api/personal/file/9b03ac6a5228765d4a77ecdee3d70296?method=download&shareKey=a1ca6aca17cbde7dda54073c8ad8871b&inline=true)

4. 性能分析
   > 1) 希尔排序增量最后一定为1
   > 2) 希尔排序为不稳定排序。
   > 3) 时间复杂度大约为O(n^1.5)
   > 4) 空间复杂度为O(1)
   > 5) 按增量分组，组内采用直接插入排序。

### 交换类排序
#### 1) 冒泡排序
1. 依次比较相邻元素，逆序则交换，n个元素重复n-1次。
2. 冒泡排序**一趟确定一个元素的最终位置**(可能会多次交换)。

2. 代码
   ```
      void bubblesorSort(int a[], int n){  // 数组元素下标从0-n-1
          for(i=n-1; i>=1;i--){ // n个关键字最多要n-1趟
              flag = 0;
              for(j=1;j<=i;j++){
                  if(a[j-1]>a[j]){
                      temp = a[j-1];
                      a[j-1] = a[j];
                      a[j] = temp;
                      flag = 1; // 如果没发生交换，则flag为0，发生交换值为1
                  }
              }
              if(flag == 0){ // 如果一趟排序，没有发生关键字交换，则证明有序，排序结束。
                  return;
              }
          }
      }
   ```

3. 性能分析
   > 1) n个关键字，需要n-1趟
   > 2) 时间复杂度最坏情况，为逆序序列，时间复杂度为O(n^2)
   > 3) 最好情况，序列有序，内层循环if始终不成立，flag为0，内层循环执行n-1次比较，执行结束。
   > 4) 空间复杂度为O(1)
   > 5) 每一趟都会确定一个元素在最终位置上。
   > 6) 24个关键字，冒泡排序最少比较次数23次(本代码中的第1趟)。

#### 2) 快速排序
1. 每一趟选择当前所有子序列的一个关键字(通常第一个)作为枢轴，将子序列中比枢轴小的移到枢轴前，比枢轴大的元素，移动到枢轴后。
2. 例题
   > ![image](https://note.youdao.com/yws/api/personal/file/36661b60354f07083588229b02628daf?method=download&shareKey=02b481903df743c9aac03658dc05e85e&inline=true)

3. 代码
   ```
      void QuickSort(int a[], int low, int high){
         int pivot;
         int i = low;
         int j = high;
         if(low < high){
             pivot = a[low];
             while(i<j){
                 while(i<j && a[j] >= pivot) j--;  // 找小于pivot的位置
                 a[i] = a[j];
                 while(i<j && a[i] <= pivot) i++;
                 a[j] = a[i];
             }
             a[i] = pivot;
             QuickSort(a, low, i-1);
             QuickSort(a, i+1, high);
         }
      }
   ```

4. 性能分析
   > 1) 平均时间复杂度O(nlogn)，最坏情况时间复杂度为O(n^2)
   > 2) 平均空间复杂度为O(logn)，递归进行，需要用到栈，最坏情况下为O(n)。
   > 3) 待排序列越接近无序，算法效率越好；若序列基本有序，则退化为冒泡排序。
   > 4) 快速排序是不稳定的排序算法。
   > 5) 当每次的枢轴把表等分为两个长度相近的子表时候，速度最快。例如：第一趟，枢轴值21将表划分为两个子表{9，17，5}和{25，23，30}
   > 6) 快排**每趟可以有一个元素处于最终位置** 上。(枢轴处于最终位置)
   > 7) 如果第一趟执行完(8，9，4，3，6，1)，10，(12，18，18)，第二趟执行结束为(1，6，4，3)，8，(9)，10，12，(18，18)，两个子序列同时排序，算第二趟。

### 选择类排序
#### 1) 简单选择排序
1. 在待排序列中，选取最小的，交换到合适位置，重复n-1次(n-1趟)。
2. 每一趟存在多次比较，找出最小的元素下标。
3. 代码
   ```
      void selectionsorSort(int a[], int n){
          for(i=0;i<n-1;i++){
              k = i;
              for(j=i+1;j<n;j++){
                  if(a[j] < a[k]) k=j;  // 最小元素下标
              }
              if(k!=i) a[i]←→[k];
          }
      }
   ```
4. 性能分析
   > 1) 时间复杂度为O(n^2)
   > 2) 循环的执行次数与初始序列无关。
   > 3) 空间复杂度为O(1)
   > 4) 简单选择为不稳定的算法。

#### 2) 堆排序(适用于关键字较多)
1. 堆排序可以看成一棵**完全二叉树**，任何非叶结点的值，都不大于其左右孩子结点的值。
2. 大顶堆(升序)：父结点大，孩子小(大顶堆的堆顶为最大元素)。
3. 小顶堆(降序)：孩子大，父结点小(小顶堆的堆顶为最小元素)。
4. 例题：判断是否构成堆
   > ![image](https://note.youdao.com/yws/api/personal/file/1bff17da0cf9e080f5476ee0edba7976?method=download&shareKey=e810aad6bca823f01837cfa0e5870dd6&inline=true)

5. 建立堆(筛选法，反复筛选的过程)，插入结点，删除结点
   > ![image](https://note.youdao.com/yws/api/personal/file/a6d2ceb55beef4794ed89d71b3de614b?method=download&shareKey=154ed00504029a45d60c305df90620aa&inline=true)
   
   ```
      插入结点：插入结点时候，需要先将插入的结点x，放在最低层的最右边，然后对插入后的堆进行调整。
      删除结点：删除结点时候，用最底层最右边的结点，覆盖删除结点的位置，并重新调整。
      
      用筛选法构造初始堆，n个元素，必须从第 n/2下取整  个元素开始进行筛选。
   ```

6. 例题：堆排序
   ```
      步骤：
      1) 首先建好大顶堆(或小顶堆)，输出堆顶x，再将堆顶元素x和最后一个元素y(编号最后)交换。
      2) 重新调整，并重复
   ```
   
   如题：
   > ![image](https://note.youdao.com/yws/api/personal/file/303eb325e9a3928c72faef8b38fdde7f?method=download&shareKey=291f27ed0393155ae780a0558af728ec&inline=true)

7. 代码：
   ```c
      typedef sqlist HeapType;  // 顺序表存储

      void HeapAdjust(HeapType &H, int s, int m){
           rc = H.r[s];
           for(j=2*s; j≤m; j*=2){
               if(j<m && (H.r[j].key < H.r[j+1].key)) ++j;
               if(rc.key ≥ H.r[j].key) break;
           
               H.r[s] = H.r[j]; s= j;
           }
       
           H.r[s] = rc;  //插入
       }

       void Heapsort(HeapType &H){
           // 对顺序表H进行堆排序
       
           // 这里是将顺序表构建为堆
           for(i=H.length/2;i>0; --i){  // 最后一个非叶子结点开始筛选，最后一个非叶节点为length/2。
               HeadAdjust(H,i,H.length);
           }
           for(i=H.length; i>1; --i){
               H.r[1] ↔ H.r[i];  // 将堆顶元素和当前未经排序子序列H.r[1...i]的最后一个记录互换
               HeapAdjust(H,1,i-1); // 将剩余的H.r[1...i-1]重新调整为大顶堆
           }
       }
   ```

8. 性能分析
   > 1. 堆排序不稳定。
   > 2. 建立堆的时间复杂度为O(n), 时间复杂度最好，最坏，平均都为O(nlogn)
   > 3. 空间复杂度为O(1)
   > 4. 适用于关键字较多的情况(例如：10000个关键字选出前10个)
   > 5. 以二叉树的任意结点出发到根的路径上所经过的结点序列按其关键字有序。
   > 6. 具有n个结点插入新元素的时间复杂度为O(logn)，删除一个元素的时间复杂度为O(logn)

### 2路归并排序
1. 例题
   > ![image](https://note.youdao.com/yws/api/personal/file/65eca0e6dbb347bf266974503d88c484?method=download&shareKey=b319e8f827ab9254298dd89daed74e50&inline=true)

2. 性能分析
   ```
      1. 时间复杂度为O(nlogn)
      2. 空间复杂度为O(n)
      3. 归并排序一轮不会确定一个元素的最终位置。
   ```

### 基数排序
1. 多关键字排序
2. 最高位优先：先按最高位排成若干子序列，然后在对子序列按次高排序。
3. 最低位优先：采用“分配”和“收集”策略。
3. 例题
   > ![image](https://note.youdao.com/yws/api/personal/file/f4d481492697fb085c8f0a6cc9ddbae5?method=download&shareKey=7399b697cb1bc8608eab868d94bdfbd3&inline=true)

4. 性能分析
   ```
      1. 对n个元素进行基数排序，每个数据基数为rd(基数为每个位的范围，例如从0-9)，有d位数字(每个关键字位数)，一趟分配和收集用时n+rd，共d趟，故总时间复杂度为O(d(n+rd))
      2. 基数排序为稳定算法。
      3. 基数排序，不需要进行关键字比较。
   ```


### 内部排序总结
1. 时间复杂度：平均情况下，快排，希尔，堆排序，归并排序，时间复杂度都为O(nlog<sub>2</sub>n)，其余都为O(n^2)
2. 空间复杂度：快排O(log<sub>2</sub>n)，归并为O(n)，基数为O(rd)，其余都为O(1)
3. **直接插入和冒泡**，在初始序列已经有序时，时间复杂度为**O(n)**
4. 稳定性：快排，希尔，堆排序，简单选择，四种为不稳定，其余都为稳定。
5. 经过一趟排序，**可以保证关键字达到最终位置**，是**交换类**(气泡，快排)和**选择类**(简单选择，堆)排序。
6. **关键字比较次数与初始序列无关**：简单选择和折半插入
7. **排序趟数与原始序列有关**：交换类(冒泡，快排)

### 外部排序总结
1. m个初始归并段进行k路归并，归并的趟数为<sup>┌</sup>log<sub>k</sub>m<sup>┐</sup>
2. 每一次归并，所有记录都要进行**两次I/O操作**
3. 置换-选择排序中，所有记录都要进行**两次I/O操作**
4. K路归并的败者树的高度为<sup>┌</sup>log<sub>2</sub>k<sup>┐</sup>+1，因此利用败者树从k个记录中选出最值需要进行<sup>┌</sup>log<sub>2</sub>k<sup>┐</sup>次比较，即时间复杂度为O(log<sub>2</sub>k)
5. k路归并败者树的建树时间复杂度为O(klog<sub>2</sub>k)
