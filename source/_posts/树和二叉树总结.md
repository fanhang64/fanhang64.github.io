---
title: 树和二叉树总结
date: 2021-01-07 18:08:15
tags: 树 二叉树 遍历二叉树 线索二叉树 霍夫曼树
categories: 数据结构与算法
---

1. 树型结构是非线性数据结构。
2. 结点的度：结点拥有的分支个数，**节点度**就是这个节点的**孩子数量** 。
3. 树的度：树中结点度的最大值。
4. 树的高度：树中结点的最大层数。
5. 结点的深度：根结点到该结点路径结点个数。
### 树的存储结构
1. 顺序存储：双亲表示法
2. 链式存储：孩子表示法和孩子兄弟表示法
3. **双亲表示法**用于**找双亲效率高**；孩子表示法和孩子兄弟表示法找孩子效率高，找双亲效率低。
4. 度为m的总结点数：`n0+n1+n2+n3+...+nm`
5. 总分支数：`1*n1+2*n2+3*n3+4*n4+...+m*nm`
6. 总分支数=总结点数-1
<!--more-->

### 二叉树(子树有左右之分，不能任意颠倒)
1. 在二叉树第i层最多有2^(i-1)个结点。
2. 深度为k的二叉树最多有(2^k)-1个结点。
3. 对于任何一棵二叉树，如果叶结点为n0则度为2的结点数为n2，则`n0=n2+1`。
4. 满二叉树和完全二叉树(除最后一层不满，其余层都是满的)。
5. 具有n个结点的**完全二叉树**的深度为h＝<sub>└</sub>log<sub>2</sub>n<sub>┘</sub>+1。
6. n个结点的完全二叉树，结点按层次从1编号有：
   - 结点i的双亲为<sub>└</sub>i/2<sub>┘</sub>,若i＝1时无根。
   - i结点的左孩子是2i
   - i结点的右孩子是2i+1
   - 结点为i所在的层为<sub>└</sub>log<sub>2</sub>i<sub>┘</sub>+1
7. n个叶子结点完全二叉树深度`└log2(2n)┘+1`

### 二叉树的存储结构
结构定义：
```C
   // 二叉链表
   typedef struct BTNode{
       DataType data;
       struct BTNode *lchild,*rchild;
   }BTNode,*BinTree;
   
   // 三叉链表
   typedef struct BTNode{
       DataType data;
       struct BTNode *lchild,*rchild,*parent;
   }BTNode,*BinTree;
```
1. 顺序存储：自上而下，自左而右的存储在一维数组，仅适合存储**完全二叉树**，第i号元素存储在一位数组下标的`[i-1]`位置。
2. 链式存储：二叉链表和三叉链表
   - 二叉链表：lchild + data + rchild
   - 三叉链表： lchild + data + parent + rchild 
3. 二叉链表含有n个结点，有n+1个空指针。
   > 2叉链表，n个结点，共2n个指针域，除了第一个结点，每个结点都有父结点，父结点指向子结点，故n-1个结点存放了地址，有2n-(n-1)=n+1个为空指针。
4. 采用三叉链表有n个结点，有n+2个空指针。
5. 五种二叉树形态
   - 空树：bt == NULL
   - 左右子树均为空： bt->lchild ==NULL && bt->rchild ==NULL
   - 右子树为空：bt->rchild == NULL
   - 左子树为空：bt->lchild == NULL
   - 左右子树均非空
6. n个结点可以构造多少种二叉树?
   > 公式：1/(1+n)Cn.2n
### 遍历二叉树
1. 每个结点仅被访问一次
2. 先序遍历，中序遍历，后序遍历只有根结点访问的先后顺序有区别，其他(例如：两个结点的先后顺序，三种方法完全相同)没区别。
3. 算法
   ```c
      // 先序遍历
      void Preorder(BTnode *bt){
          if (bt){
              visit(bt->data);
              Preorder(bt->lchild);
              Preorder(bt->rchild);
          }
      }
      
      // 中序遍历
      void InOrder(BTNode *bt){
          if (bt){
              InOrder(bt->lchild);
              visit(bt->data);  // 移动到下面为后序遍历
              InOrder(bt->rchild);
          }
      }
      
      // 层次遍历
      // 思路：利用一个队列，首先将根(头指针)入队列，以后若队列不空则取队头元素p，
      // 若p不空则访问，然后将其左右子树入队列，如此循环直到队列为空。
      void levelOrder(BinTree bt){
          initEqueue(Q);  // Q为队列
          Enqueue(Q, bt);  // 根结点入队
          
          while(!QueueEmpty(Q)){
              DeQueue(Q, p);
              if (p){
                  visit(p);
                  Enqueue(p->lchild);
                  Enqueue(p->rchild);
              }
          }
      }
      
      // 使用循环队列的层次遍历
      void levelOrder(Bintree *bt){
          const int Maxsize = 1024;
          Bintree q[maxsize];  // 等同 BTNode * q[maxsize]
          int front, rear;
          
          // 初始化队列
          front = rear = 0;
          // 根入队列
          q[rear] = bt;
          rear = (rear +1)% maxsize;
          
          // 队列不空时循环
          while(!front == rear){
              p = q[front];
              front = (front +1) %maxsize;
              if (p){
                  visit(p->data);
                  q[rear] = p->lchild;
                  rear = (rear +1)%maxsize;
                  q[rear] =p->rchild;
                  rear = (rear +1)%maxsize;
              }
          }
      }
      
      // 非递归中序遍历
      思路：指针p从根开始，首先沿着左子树向下移动，同时入栈保存路径结点(不访问)，当到达空子树后需要退栈访问结点，然后移动到右子树。
      void InOrder(Bintree bt){
          InitStack(S);
          p = bt;
          while(p || !StackEmpty(S)){
              if (p){
                  Push(S, p);
                  p = p->lchild;
              }else{
                  Pop(S, p);
                  visit(p);
                  p = p->rchild;
              }
          }
      }
      
      // 先序非递归
      void PreOrder(BtTree bt){
          initStack(S);
          p = bt;
          while (p || !StackEmpty(S)){
              if (p){
                  visit(p->data);
                  Push(S, p);
                  p = p->lchild;
              }
              else{
                  pop(S, p);
                  p = p->rchild;
              }
          }
      }
      
      // 后序遍历非递归
      // 思路：分别从左子树和右子树两次返回根结点，只有从右子树返回时才访问根结点，增加一个栈标记到达结点的次序
      void PostOrder(Bintree bt){
          InitStack(S);
          InitStack(tag);
          p = bt;
          while(p || !StackEmpty(S)){
              if (p){
                  push(S, p)
                  Push(tag, 1)  // 第一次入栈标识
                  p = p->lchild;
              }else{
                  // 从左子树返回，二次入栈，然后p转右子树
                  Pop(S, p);
                  Pop(tag, f);
                  if (f == 1){
                     Push(S, p);
                     Push(tag, 2);
                     p = p->rchild;
                  }else{
                      // 从右子树返回，访问p，转上层
                      visit(p);
                      p = NULL; // 使下一步继续退栈
                  }
              }
              
          }
      }
      
      // 三叉链表的中序遍历
      void InOrder(Bintree bt){
          if (bt == NULL){
              return;  // 空树直接返回
          }
          p = bt;
          while(p ->lchild) 
              p = p->lchild;
          while(p){
              visit(p);
              if (p->rchild){
                  p = p->rchild;
                  
              }
          }
      }
   ```
4. 非空二叉树**先序遍历和后序遍历具有相同的结点访问顺序**，则一定**只有根结点**。
5. 若非空二叉树**先序遍历和后序遍历访问顺序相反**，则**二叉树所有结点无左孩子或无右孩子(向右斜线，或向左斜线)**。

### 遍历二叉树应用
题型：给出前，中，后序其中两个确定一棵二叉树。
a. 已知前序和中序，可以唯一确定二叉树。
   例如： 
   > ![image](https://note.youdao.com/yws/api/personal/file/f9b02a0b9ba0e458c7b2a055d88483d3?method=download&shareKey=bfce63c71deb940ae92e8f37e87c7cca&inline=true)

b. 已知后序和中序，可以唯一确定二叉树。
   例如：
   > ![image](https://note.youdao.com/yws/api/personal/file/7c037a8c962abf301d2fd0dfaf05fcad?method=download&shareKey=f2daf7aa290911bd389b15818f3cd227&inline=true)

c. 已知前序和后序，不一定能确定。
   虽然前序后序不能确定唯一二叉树，但可确定父子关系，例如：若前序为XY，后序为YX，则X为Y的父结点。

d. 算法
```c
   // 求二叉树结点的个数
   int NodeCount(Bintree bt){
       if (p == NULL){
          return 0;
       }
       return 1+ NodeCount(bt->lchild) +NodeCount(bt->rchild);
   }
   // 求二叉树的深度
   int Depth(Bintree bt){
       if (p == NULL){
           return 0;
       }
       return 1+ max(Depth(p->lchild), Depth(p->rchild));
   }
   // 求二叉树叶子结点的个数
   int LeafCount(Bintree bt){
       if (p == NULL){
           return 0;
       }
       else if(bt->lchild == NULL && bt->rchild ==NULL){
           return 1;
       }
       else return LeafCount(bt->lchild) + LeafCount(bt->rchild);
   }
```

### 线索二叉树
引入二叉线索树目的是**加快查找结点的前驱和后继**。
1. 结点结构(5部分)
   ```
      lchild ltag data rtag rchild
      
      其中：ltag, rtag为标识位，当tag=0时表示child指针指向结点，
      当tag=1时，则表示child指针为线索，指向结点的前驱或者后继
   ```
2. 线索化
左边空指针可以作为前驱索引，右边空指针可以作为后继线索，可以`全线索化(例如面的，先序和中序)，也可以部分线索化(例如：下面的后序)`。
   - 先序线索化
     > ![image](https://note.youdao.com/yws/api/personal/file/7e392b0b96583760e9617839620fb047?method=download&shareKey=0fa625d9cabc9e218eb97e94c5d271b7&inline=true)
   - 中序线索化
     > ![image](https://note.youdao.com/yws/api/personal/file/08df272071b2fb32c34c7d4598142429?method=download&shareKey=b0ef8c40d43d6687d966c2ccd4ff6dd3&inline=true)
   - 后序线索化(只画出后序的后继线索)
     > ![image](https://note.youdao.com/yws/api/personal/file/644ae078b761f8592c3c206bc0b328d7?method=download&shareKey=44910cf629d9c8cf828314373b1468fc&inline=true)
3. 中序线索化代码实现
   ```cpp
      // 中序非递归遍历线索树
      typedef enum PointerTag{Link, Thread};  // Link=0 指针，Thread =1 线索
   
       typedef struct BiThrNode{
           EmemType data;
       
           struct BiThrNode *lchild, *rchild;
           PointerTag Ltag, Rtag;  // 左右标志，为0时表示lchild指向左孩子，为1时表示指向前驱
       }BiThrNode, *BiThrTree;
   
       // 线索化，在线索链表添加一个头结点，头结点的lchild指向，原来的根结点，头结点的rchild指向原来线索链表中序遍历的的最后一个节点
       // ，同时中序遍历的第一个节点的lchild和最后一个节点的rchild指向头结点。
       Status InorderTraverse_Thr(BiThrTree T){
           // 这里T指向一个头结点，头结点的lchild指向根结点
           BithrTree p;
       
           p = T->lchild;  // p指向根结点，
       
           while(p != T){  // 空树或者遍历结束时候p == T，此时p指向头结点
               while(p->Ltag == link){p=p->lchild;}
           
               printf(p->data);  // 访问左子树为空的节点
           
               while(p->Rtag == Thread && p->rchild != T){
                   p=p->rchild;
               
                   printf(p->data);  //访问后继节点
               }
               p = p->rchild;
           }
       }
   ```
4. **后序线索树**需要栈的支持。
5. 二叉树线索化后，仍不能有效求解的问题是`后序线索二叉树中求后序后继`。(原因：先序遍历（中左右）、中序遍历（左中右）的最后访问的节点都是左或右叶节点，叶节点是没有子树的，所以两个指针域空出来了，可以存放线索指针。但是后续遍历（左右中），最后访问的是子树的根节点，而子树根节点的两个指针域都指向子树了，所以不能空出来存放线索信息。)

### 树的存储结构
1. 双亲表示法
   1) 存储表示
      ```c
         typedef struct PTNode{  //  结点结构
            ElemType data;
            int parent;  // 双亲位置(数组下标)
         }PTNode;
         
         typedef struct{
             PTNode nodes[max_tree_size];
             int r, n;  // 根位置和结点数
         }
         
      ```
    
   2) 画图
      > ![image](https://note.youdao.com/yws/api/personal/file/057aa7a34b72e4efa3d75c15040aeded?method=download&shareKey=ebb786e2703dd646ce628885274e2751&inline=true)

2. 孩子表示法
   1) 存储表示
      ```c
         typedef struct CTNode{  // 孩子结点，孩子链表的结点
             int child; 
             struct CTNode* next;
         }* ChildPtr;
         
         typedef struct{
             ElemType data;
             ChildPtr firstchild;  孩子链表的头指针
         }CTBox;
         
         typedef struct {
             CTBox nodes[size];
             int r, n;  // 根的位置和结点数
         }
      ```

3. 孩子兄弟表示法
   1) 存储表示
      ```
         typedef struct CSNode{
             ElemType data;
             struct CSNode * firstchild, *nextsibling;
         }CSNode, *CSTree;
      ```

   2) 画图
      > ![image](https://note.youdao.com/yws/api/personal/file/882b5cc131da67a3d26061fc9ac08246?method=download&shareKey=04ca146e9504c78237f7034747b6dd47&inline=true)

### 树与二叉树的转换
特点： 由树转化为二叉树，根结点无右孩子。
题型：画图将树转为二叉树，并将二叉树转树。
> ![image](https://note.youdao.com/yws/api/personal/file/42d1c7401ced419c474718fd5c3de7eb?method=download&shareKey=bc22dede75c619038f414a9149f26ea4&inline=true)

### 森林和二叉树的转换
题型：森林和二叉树相互转换
> ![image](https://note.youdao.com/yws/api/personal/file/83893627e2f32455325b42cf107e230d?method=download&shareKey=f661644d99ddf710d971c751aff1d187&inline=true)

### 树和森林的遍历
1. 树的先根遍历对应二叉树的`先序遍历`；树的后根遍历对应二叉树的`中序遍历`。
2. 森林的先序遍历对应二叉树的`先序遍历`，森林的中序遍历对应二叉树的`中序遍历`。

### 赫夫曼树(最优二叉树)和赫夫曼编码
特点：带权路径最短。
1. 路径：是树从一个结点到另一个结点的
2. 树的带权路径长度：所有**叶子结点的带权路径长度之和**，记作WPL。
3. 性质：
   - 每个初始结点都为叶结点。
   - 权值越大离根结点越近，权值越小离根结点越远。
   - 哈夫曼树没有度为1的结点。
   - n个叶子结点的哈夫曼树，结点总数为`2n-1`，其中度为2的结点个数为`n-1`。
4. 构造赫夫曼树(每次取两个最小的树组成二叉树)
注意：同样一组权值可能构造不同的霍夫曼树，但是带权路径长度一定是一样的。
   > ![image](https://note.youdao.com/yws/api/personal/file/cd0465e46960b2484bf69bc47fae1a2f?method=download&shareKey=f16cd163013521a247d02dc525910bb2&inline=true)
5. 霍夫曼编码(前缀码)
左分支为0，右分支为1，从根到叶子的路径构成叶子的前缀编码。
   > ![image](https://note.youdao.com/yws/api/personal/file/83842669d04408584dc9ec4151ef542f?method=download&shareKey=af8fe240f178bf27b062d3ec7b6eb649&inline=true)
6. 赫夫曼n叉树
   - 若构造n叉树时，发现结点不能构造时，需要补上权值为0的结点，让序列构成霍夫曼叉树序列。
   - 此时只有度为0和度为n的结点
7. 判断字符是不是前缀编码?
   ```
      只需要判断是否有其他编码以这个编码开头。
      A. 01 0000 0001 001 1
      D. 0 100 110 1110 1100
      
      看A 的01 比较0000 0001 001 1都不是01开头
      看A 的0000 比较，不存在
      其他相同，比较完发现A是前缀编码。
      
      看D 比较后发现110 是1100的开头。故D不为前缀编码
   ```
8. 一棵哈夫曼树215个结点，对其进行编码，共得到多少个码字?
   ```
      n0+n2 =215
      n0 = n2 + 1
      带去可得n0 = 108
   ```
9. 只有叶子结点有关键字值，**非叶结点无关键字值**。