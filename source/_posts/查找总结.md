---
title: 查找总结
date: 2021-01-07 18:11:50
tags: 
- 查找 
- 平衡二叉树 
- B-树 
- B+树
categories: 数据结构与算法
---

### 基本概念

1. 静态查找表：只进行**查找操作**，例如：顺序查找，折半查找，索引顺序表。
2. 动态查找表：可进行**查找**，**插入**，**删除**，例如：二叉排序树，平衡二叉树(AVL树)，B树等。
3. 平均查找长度(ASL)：关键字比较次数的平均值。

### 顺序查找
1. 特点：简单，既可以顺序，也可以链式。
2. 等概率情况下，查找成功的平均查找长度：**ASL=(1+2+3..+n)/n = (1+n)/2**。(第一次查找成功，比较1次，第二次比较两次成功...)
3. 顺序查找的判定树为一棵深度为n的单分支的树。
4. 时间复杂度为O(n)
5. 代码：
<!--more-->
   ```
      # 在数组a的前n个元素中查找x
      int search(int a[], int n, int x) // n为长度，x为要查找的元素
      {
          for (int i = n-1; i>= 0;i++){
              if (a[i] == x){
                 return i;
              }
          }
          return -1;  //未找到
      }
   ```

### 折半查找
1. 适用于**有序的顺序表**，只能**顺序存储结构**。
2. 代码
   ```
      // 非递归折半查找
      int binarysearch(int a[], int n, int x){
          low = 0; high = n-1;
          
          while(low <= high){
              mid = (low + high) /2;
              
              if(a[mid] > x){
                  high = mid -1;
              }else if(a[mid] < x){
                  low = mid +1;
              }else{
                  return mid;
              }
          }
          return -1;
      }
      
      // 递归折半查找
      int binarysearch(int a[], int low, int high, int x){
          if (low > high){
              return -1;
          }
          mid = (low+high)/2;
          if (a[mid] == x){
              return mid;
          }
          else if (a[mid] > x){
              return binarysearch(a, low, mid-1, x);
          }else{
              return biarysearch(a, mid+1, high, x);
          }
      }
   ```
3. 判定树类似于完全二叉树，深度为 **<sub>└</sub>log<sub>2</sub>n<sub>┘</sub>+1** 

4. 画判定树
   > 例如：画出n=10的有序表折半查找的判定树。</br></br>
     ![image](https://note.youdao.com/yws/api/personal/file/e951a2926cda1e83a54d6fddfdbc40ed?method=download&shareKey=19d30fc5bf1a73ce82730f2226a4c30f&inline=true)

5. 时间复杂度为O(logn)

### 索引顺序表
1. 分块，块间有序，块内无序，对应索引表有序，顺序表无序。
2. 索引顺序表的查找性能在顺序查找和折半查找之间。
3. 查找过程：
   - 先确定待查记录所在块(顺序，折半查找)。
   - 在块内查找(顺序查找，因为块内无序)
4. 平均查找长度ASL= L<sub>b</sub> + L<sub>w</sub>
5. 既希望较快的查找，又便于线性表动态变化的查找方法是：**索引顺序查找**
6. 例题：
   ```
      具有144个记录，采用分块查找。索引和顺序表都采用顺序查找，每块长度为8，则平均查找长度为
      
      解： ASL = lb + lw
         144/8 = 18块
         lb = (1+2+3+...+18) /18 = 19/2   // 等概率
         lw = (1+2+3+...8)/8 = 9/2
         ASL = 19/2+9/2 = 14
         
         如果索引表折半查找，要计算折半查找平均查找长度 + 顺序表内的顺序查找平均查找长度
   ```

### 二叉排序树
1. 二叉排序树：空树或这样的一棵树，左子树不空，则左子树所有结点均小于根结点，若右子树不空，则右子树所有结点，均大于根结点。
2. 若用**中序遍历**二叉排序树得到结果将从小到大有序。
3. 二叉排序树查找算法：
   ```
      # 递归算法查找
      Bitree BstSearch(Bitree bst, int x){
          if (bst == NULL){
              rerurn NULL;
          }
          if (bst->data > x){  // 如果大于x，说明要查找的值在左子树
              return BstSearch(bst->lchild, x);
          }else if (bst->data < x){
              return BstSearch(bst->rchild, x);
          }else{
              return bst;
          }
      }
      # 非递归查找
     Bitree BstSearch(Bitree bst, int x){
         p = bst;
         while(p){
             if (p->data == x){
                 return p;
             }else if (p->data >x){
                 p = p->lchild;
             }else{
                 p = p->rchild;
             }
         }
         return NULL;
     }
   ```
4. 二叉排序树插入步骤：
   ```
      1) 若为空树，直接插入
      2) 若非空，首先查找这个元素是否存在，如果存在，什么也不做，如果不存在，则插入到合适位置。(查找不成功的位置，即为插入位置)
      
      int BST_Insert(Bitree &T, int k){
          if(T==NULL){  // 当前为空，说明找到了插入位置，创建新节点进行插入
              T = (Bintree)malloc(sizeof(BNode));
              T->data = k;
              T->lchild = T->rchild = NULL;
              return 1;  // 成功
          }
          else if(k == T->data){  // 存在相同关键字
              return 0;
          }else if(k < T->data){
              return BST_Insert(T->lchild, k);
          }else{
              return BST_insert(T->rchild, k);
          }
      }
   ```
5. 插入操作时，新插入的结点总是**叶子结点**。
6. 二叉排序树构造就是多次调用插入操作。
   ```cpp
      void create_BST(Bitree &T, int keys[], int n){
          T = NULL;  // 创始化
          int i=0;
          while(i<n){
              BST_Insert(T, keys[i]);  // 依次插入关键字
              i++;
          }
      }
   ```

7. 二叉排序树删除步骤
   ```
      1) 删除叶子结点，直接删除。
      2) 删除的结点有左子树或者有右子树(有其中一个)，则子树替代删除结点位置。
      3) 删除结点左右子树都存在，则将二叉树按中序遍历，序列的直接后继(直接前驱也行)代替，并删除直接后继(前驱)。
   ```

8. 计算平均查找长度`ASL=(第一层x个数+第二层x个数+第三层x个数+..)/结点总个数`。
9. 平均查找长度也为**O(logn)**
10. 如果二叉树插入结点之后为单支树，则查找退化为顺序查找，平均查找长度为 **(1+n)/2**
11. **二叉排序树和二分查找判定树区别**：二分查找判定树唯一，二叉排序树查找不唯一，相同关键字插入顺序不同可能会导致生成不同的二叉排序树。

### 平衡二叉树
1. 平衡因子：左子树深度-右子树深度
2. 平衡二叉树平衡因子只能为**0，1，-1**
3. 平衡二叉树是特殊的**二叉排序树**
4. 失去平衡时候调整
   ```
      步骤：
         1) 首先找失去平衡的最小子树
         2) 根据相对判断类型
         3) 调整，按照大小值，谁在中间，谁做根结点。
   ```
5. 画图
   > ![image](https://note.youdao.com/yws/api/personal/file/7832d941dc0fb572b961c0ae7b941f46?method=download&shareKey=43a5d03f061a6899acc799fb32707545&inline=true)

6. 平均查找长度也是`(第一层乘个数+第二层乘个数+...)/个数`
7. 求n个结点的平衡二叉树**最大高度**：即求高度为h的平衡二叉树的**最少结点**。也是非叶子结点，所有平衡因子都为1的情况)
8. 求**高度为h**的平衡树的**最少结点数**公式：**n<sub>h</sub>= F<sub>h+2</sub>-1**，其中F为斐波拉契数列第h+2项，当F<sub>h</sub>=0，1，2，当h为0，1，2时

### B-树和B+树
1. 二叉排序树为二路查找，B-树为多路查找。
2. 一棵m阶的B-树，或为空树，或满足： 
   1) 每个结点至多有m个子树(分支)(即最多m-1个关键字)；
   2) 若根结点，不是叶子结点，则**至少两棵子树(一个关键字)**； 
   3) 除了根，叶子结点之外的结点，至少有<sup>┌</sup>m/2<sup>┐</sup>棵子树； 
   4) 所有叶子结点**在同一层**，不含信息，表示查找失败。
   5) 具有n个关键字的m阶B树，则有**n+1**个叶结点(查找失败)。

3. B-树的查找
4. B-树的创建(多次插入操作)</br>
注意：操作时，首先计算每个结点关键字个数，例如：m阶B树，每个结点最多m-1个关键字，根结点最少一个关键字，非根结点的非叶子结点，最少是┌m/2┐-1个关键字，最多m-1个关键字。
   > ![image](https://note.youdao.com/yws/api/personal/file/3f61059409b0af4e787054f1e1e7f6e8?method=download&shareKey=3518e06808f74cec65956dbbec858ef0&inline=true)

5. B-树的删除
   ```
      1. 要删除的结点在终端结点(叶子结点)
        1) 要删除的结点内关键字个数＞┌m/2┐-1，此时可以直接删除。(关键字个数大于最小值)
        
        2) 要删除的结点内关键字个数＝最小值┌m/2┐-1，其中左，右兄弟结点中存在关键字个数大于最小值┌m/2┐-1的结点，则从兄弟结点借关键字。然后通过父结点调整。
        
        3) 要删除的结点关键字个数＝最小值┌m/2┐-1，左右兄弟关键字个数等于最小值(不能借)，这时要结点合并，讲剩余结点的关键字与父结点的关键字进行合并，双亲结点下来与孩子合并，双亲结点关键字减1。
        
      2. 要删除的结点不终端结点
        1) 如果关键字的左右子树中存在大于┌m/2┐-1结点，则左子树找最右边关键字(删除关键字的前驱)，右子树找最左边关键字(后继关键字)，覆盖要删除的关键字。
         
        2) 如果关键字的左右子树都已经处于最小的关键字个数，则直接合并子结点，删除关键字
   ```
   例题：</br>
   > ![image](https://note.youdao.com/yws/api/personal/file/f9ac41f3b088e3a8b31531bf7cfc2d0e?method=download&shareKey=75b142a1b1a23a24e81b9112935f0649&inline=true)

6. B+树性质概念
   1. n个关键字有**n个分支**。对比B树，n个关键字，n+1个分支
   2. B+树的叶子结点**包含信息**。对比B树不包含。
   3. B+树所有非叶子结点，**只起索引作用**，不包含关键字对应的存储地址。对比B树，每个结点关键字对应存储地址。
   4. B+树**有一指针**指向最小的叶子结点，**可进行顺序查找**。
   5. B+树有两种查找运算：一种是从最小关键字开始的顺序查找，另一种是从根节点开始的多路查找。

### 哈希表
1. 对散列表进行查找的时间复杂度为O(1)，与表中元素个数无关。
2. 哈希表的平均查找长度与n不直接相关，而是取决于装填因子`（α=记录个数/地址空间）`和处理冲突方法。
3. 散列查找思想：计算出散列地址进行查找，然后比较关键字判断是否查找成功。
4. 为了有效应用Hash表，必须解决的两个问题是**构造Hash函数**和**确定解决冲突的办法**

#### 1. 构造散列函数方法
1) 直接定址法
   > H(key) = a*key +b </br>
     特点：浪费空间，不会产生冲突

2) 除留取余法
   > H(key) = key % p  </br>
     // 假设表长m，其中p为不大于，或等于m的最大素数

3) 数字分析法
    
#### 2. 处理冲突方法(冲突后，找下一个位置)

注意：开放定址法，不能随意删除已有元素。

1) 开放定址法H = (H(key) + d<sub>i</sub>) % m
   1. 线性探测再散列
      > H(key) + 1，H(key)+2，...</br>容易造成“聚集”，从而降低查找效率，聚集是因为解决冲突的方法原则不当。

   2. 二次探测再散列
      > H(key) + 1^2，H(key) - 1^2，</br>H(key) + 2^2，H(key) - 2^2，...</br>解决聚集问题

   3. 伪随机探测再散列
      > H(key) + f(1)，H(key) + f(2)，...</br>
        注意：其中伪随机函数，题中会给

2) 链地址法
   > 构造链表，将同一个地址的关键字存储在一个单链表中。

3) 再哈希法

#### 3. 性能分析
1. 除留取余+线性再散列例题
   > ![image](https://note.youdao.com/yws/api/personal/file/1ae5f2b1f55398c9c3042d6305d7666c?method=download&shareKey=871831886cdd3046ffaa5008626c10cd&inline=true)
   
2. 除留取余+链地址法
   > ![image](https://note.youdao.com/yws/api/personal/file/e01a9e91af877fc978fdbcc1584733f4?method=download&shareKey=a2b74604a077f0c6c2bc667e2a395343&inline=true)

注意：</br>
1. 关于计算平均查找失败长度时，**空位置是否计算在内**：**顺序表**时，空位置的比较次数也**要计算在内**；**链表**(链地址法)时，空指针**不计算在内**。
2. **计算查找失败平均查找长度**时，如果除留取余法，**分母为p**，分子也应该只计算0-(p-1)的查找次数。
3. 查找成功是**除以关键字个数**；查找失败**除以模值**。查找失败如果不是除留取余法，则除以散列表空间个数(例如0-15则除以16)。
4. 采用开放定址法处理散列表冲突时，其平均查找长度是**高于链地址法** 。