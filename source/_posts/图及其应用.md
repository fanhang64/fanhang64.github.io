---
title: 图及其应用
date: 2021-01-07 18:09:58
tags:
- 图
- 图的遍历
- 图的应用
categories: 数据结构与算法
---

1. 图由**结点和边**的集合构成。(图不可为空图，树可为空树)
2. 在无向图中，边(vi,vj)等价于有向图的<vi,vj>与<vj,vi>。
3. 在**无向图**中，与顶点相关边的条数为**顶点的度**。
4. 在**有向图**中，指向顶点的度，**由顶点发出的边的条数为**顶点的出度。
5. 有向完全图：若有向图有n个顶点，则最多有`n(n-1)`条边[任意两个顶点两条边]。
6. 无向完全图：有n个顶点，任意两个顶点之间都存在边，最多有`n(n-1)/2`条边。
7. 连通：从顶点vi到顶点vj**有路径**，则vi与vj连通。
8. **连通图**：任意两个顶点之间都连通。
9. **连通分量**：极大连通子图(极大说的是包含所有边)。
10. 在有向图中，若顶点vi与vj，从vi到vj，和从vj到vi都有路径，则称图为**强连通图**。
11. 极大强连通子图称为**强连通分量**。
12. 顶点为n个的无向连通图**至少有n-1**条边。
13. 顶点为n个的**有向强连通图**则**至少有n**条边(此时构成环)。
14. 生成树(极小连通子图)：保持连通，边最少，**不唯一**。
15. 简单路径：顶点不重复出现的路径。
16. 无向图的图的度：**边数为无向图所有顶点度的一半**。
<!--more-->

### 图的存储结构
邻接多重表只适用于**无向图**，十字链表适用于**有向图**，其余既可以**无向图和有向图**。
1. 邻接矩阵法
   - 图的**顺序存储结构**。适用于**稠密图**，邻接矩阵法空间复杂度为**O(n^2)**，与边的数目无关。
   - 无向图中，矩阵是**对称**的，其中第i行**或**第i列的和为顶点i的**度**，并且唯一。
   - 有向图中，邻接矩阵**可能为对称**。**第i行**元素和为顶点i的**出度**，**第i列**元素之和为顶点i的**入度**。
   - 结构体定义
     ```
        const int Maxsize = 100 // 最大顶点数
        typedef struct Graph{
            VertexType vexs[Maxsize];  // 顶点向量 可以定义为char类型
            ArcType arcs[Maxsize][Maxsize];  // 邻接矩阵 int 类型
            
            int vexnum,arcnum; // 顶点和边的个数
        }Graph;
     ```
   - 对于图(有向，无向)：有边为1，否则为0。
   - 对于网(有向有权图)：有边为权值，否则为∞
   - 画图
     - 对于无向图
       > ![image](https://note.youdao.com/yws/api/personal/file/ab95c2833a86d814719c9cfa30583812?method=download&shareKey=db6bba9480b7a9e3689a7a3377448ce6&inline=true)

     - 对于有向图
       > ![image](https://note.youdao.com/yws/api/personal/file/3c1a1a945a76c336735018e645cb241f?method=download&shareKey=e6d2fcdc0e044eaccbed1bc5256e24ef&inline=true)

     - 对于网(有向有权图)
       > ![image](https://note.youdao.com/yws/api/personal/file/b4acf31c23919630799621cf36fffd3f?method=download&shareKey=8d59973424972428361072fac2805c85&inline=true)

2. 邻接表法
   - 为每个顶点建立一个单链表，第i个结点的表头指针指向关于vi顶点的边表。邻接表法更适用于**稀疏图**。 ，且邻接表画图结果不唯一。
   - 邻接表由`顶点表(顺序存储)`和`边表(链式存储)`组成。
   - 邻接表占用存储空间与**结点和边都有关**。
   - 结点
     ```
        顶点表(链域，数据域)
        firstarc data
        
        边表(邻接点域，链域，数据域)
        adjvex  nextarc info
        
        typedef struct node{  // 边表结点
            int adjvex;  // 该弧所指向的顶点的位置
            struct node *next;
        }EdgeNode;
        
        typedef struct vnode{
            char data;  // 顶点数据
            EdgeNode *first;  // 指向第一条该顶点的弧
        }VNode;

     ```
   - 在无向图中，顶点vi的度为第i结点指向的**边表中结点数**。
   - 在有向图中，边表中结点数只是顶点i的**出度**。要求入度需要遍历整个邻接表。
   - 画法
     - 无向图
       > ![image](https://note.youdao.com/yws/api/personal/file/48411a57edabad8de321bb6b1e284a3d?method=download&shareKey=109aa3217ac867d29739bb3006124421&inline=true)

     - 有向图
       > ![image](https://note.youdao.com/yws/api/personal/file/d7a725df5eb4247e31436e725da5bd60?method=download&shareKey=0d0ef687b76086eb1132bf9fbb91b2c8&inline=true)

     - 逆邻接表(为了方便确定顶点的入度)
       > ![image](https://note.youdao.com/yws/api/personal/file/07f7a95c9f9eb5d16b45043a4a74a251?method=download&shareKey=bd918b4dff4f9831e956335cf55ca3f8&inline=true)

3. 十字链表
   - 十字链表相当于邻接表和逆邻接表结合。
   - 结点结构
     ```
        顶点结点(结点，指向入边第一个结点，指向出边第一个结点)
        data  firstin  firstout
        
        弧结点(头，尾，指向下一个入边，下一个出边)
        start  end  nextin nextout
     ```
     
   - 画图
     > ![image](https://note.youdao.com/yws/api/personal/file/e114c169be8a4cba335d737ba41f89af?method=download&shareKey=6fbff16ff753fe6d1adda74f6792cf80&inline=true)
    
4. 邻接多重表
   - 适用于无向图，不能存储有向图。

例如：
最适合稀疏无向图：邻接多重表。
最适合稀疏有向图：十字链表。

### 图的遍历
无论是深度优先，还是广度优先，时间复杂度**采用邻接表**时都为**O(n+e)**，空间复杂度为**O(n)**，采用**邻接矩阵**时时间复杂度为**O(n^2)**。

1. 深度优先遍历
   - 类似树的**先根遍历**
   - 同一个图的深度优先遍历**序列可能不同**。
   - 基本思想：首先访问出发点v，标记为已访问过，然后选取与v相邻的未访问的w，访问，然后选取与w相邻的未访问的顶点，重复。当所有相邻的顶点都访问过，依次退回到最近访问，然后找未访问顶点，重复上述访问操作，直到图中所有顶点访问结束。
   - 可以利用深度优先遍历**判断是否存在回路**。

   - 画图
     > ![image](https://note.youdao.com/yws/api/personal/file/77f1f5ebd69e3085f4a02357778fc10b?method=download&shareKey=ee635ee44bc8ef792b69d09fc27735cc&inline=true)

   - 代码实现
     ```cpp
        bool visited[max_vertex_num];  // 标记访问数组
        void DFSTraverse(Graph G){
           // 初始化为false
           for(i=0;i<G.vexnum;i++){
               visited[i] = false;
           }
           
           //从0号开始遍历，遍历每个连通分量
           for(i=0;i<G.vexnum;i++){
               if(!visited[i]){
                   DFS(G, i);
               }
           }
        }
        
        void DFS(Graph G, int v){
            visit(v);  // 访问结点v
            visited[v] = true;  // 将标记数组，标记为已访问
            for(w=FirstNeighbor(G, v); w>=0; w=NextNeighbor(G, v, w)){  // w为u的尚未访问的邻接结点
                if(!visited[w]){
                    DFS(G, w);
                }
            }
        }

     ```

2. 广度优先遍历
   - 类似**层次遍历**二叉树
   - 广度优先遍历需要借助一队列。
   - 广度优先生成树，若给定**邻接矩阵存储**则表示唯一，若给定**邻接表**则表示不唯一。
   - 画图
     > ![image](https://note.youdao.com/yws/api/personal/file/0f86452a5a2fb1c4a06f0fcb2c37351b?method=download&shareKey=afe9044c9c9d76f9bbc247afe36ca50f&inline=true)
   - 代码
     ```cpp
        bool visited[max_vex_num];  // 最大顶点个数，用于标记结点是否已被访问
        void BFSTraverse(Graph G){ // 初始化
           for(i=0;i<G.vexnum;i++){
              visited[i] = false;
           }
           InitQueue(Q);
           for(i=0;i<G.vexnum;i++){  // 从0号顶点开始遍历，且循环目的是对每个连通分量调用一次BFS
              if(!visited[i])
                BFS(G, i);
           }
        }
   
        void BFS(Graph G, int v){
          visit(v);  // 访问v顶点
          visited[v] = true;
          Enqueue(Q, v); // 顶点v入队列
          while(!isEmpty(Q)){
              DeQueue(Q, v);  // v出队
              for(w=FirstNeighbor(G, v); w>=0; w=nextNeighbor(G, v,w)){
               // 获取所有与v邻接的顶点
                  if(!visited[w]){  // 逐个判断并访问
                      visit(w);
                      visited[w] = true;
                      Enqueue(Q, w);
                  }
              }
           }
        }
     ```

### 最小生成树(MST)(带权值)[都是针对无向图]
(1) 最小生成树的边数为**顶点数-1**。
(2) 最小生成树代价唯一，最小生成树的树形不唯一。

1. 普里姆算法[要求代码]
   - 从顶点出发每次**选权值最小的边**。
   - 判断：无向图一定有唯一形态的最小代价生成树。(错)  // 当所有**权值不相同**时，生成的最小生成树才唯一。
   - 使用**邻接矩阵**存储时，时间复杂度为：O(n^2)
   - 使用**邻接表**存储时，时间复杂度为：**O(n+e)**
   - 适用于**稠密图**。特点：只与顶点个数n有关，与边的数目e无关。
   - 画图
     > ![image](https://note.youdao.com/yws/api/personal/file/56471aec0b4691f8151875b8f669fbf5?method=download&shareKey=bf311ebd3b5fe25df97e69c5d502579f&inline=true)

   - 代码
   
2. 克鲁斯卡尔算法
   - 无需从顶点出发，只需要找权值边最小。
   - 适用于**稀疏图**。特点：只与边的数目e有关，与定点个数n无关。
   - 画图
     > ![image](https://note.youdao.com/yws/api/personal/file/2c99a97b92d87c16a279c799aab035f0?method=download&shareKey=47ae18885976e73f9e54f8f8f2b2ee0f&inline=true)

   - 时间复杂度为：**O(eloge)**  // e为边数

### 拓扑排序(每次删除入度为0的顶点并输出) [不要求代码]
1. 有向无环图(DAG)。AOV网
2. 拓扑排序结果不一定唯一。
3. 算法思想：
   1. 从DAG中选择一个 **没有前驱结点的结点A(入度为0)** 并输出
   2. 从图中删除所有以A为起点的边
   3. 重复1.2操作直到图为空，或者不存在无前驱顶点为止(存在环)。

4. 画图
   > ![image](https://note.youdao.com/yws/api/personal/file/96e8f9ff5ab8c93fa05c234b31be9412?method=download&shareKey=3b1bfaa5f87a20311b56bace10c9656d&inline=true)

### 最短路径
1. 迪杰斯特拉算法[要求代码]
   - 用于求**某一顶点到其余各顶点的最短路径**。
   - 迪杰斯特拉适合求解**带回路的有权图的最短路径**，也可以求**任意两个顶点的最短路径**，不适合**求带负权值的最短路径**问题。
   - 画图
     > ![image](https://note.youdao.com/yws/api/personal/file/1c701ad30693b8b31c15fd00f9a0d813?method=download&shareKey=f5ecd9c6ee054d4a9875fee6b8138590&inline=true)
     注意：图中的vj为从v0出发到vj的最短路径。再次比较时，用这个到其他顶点距离与原来距离比较。

   - 代码
   

2. 弗洛伊德算法
   - 用于求**每对顶点直间的最短路径**
   - 时间复杂度为O(n^3)
   - 画图
     > ![image](https://note.youdao.com/yws/api/personal/file/16f6cbd4ab93789a98f90c4ceee10db2?method=download&shareKey=2b6c1ea4e369fc79de61bf399a387fa5&inline=true)

### 关键路径(找最长的路径)
1. AOE网，有向无环图。
2. 边为**活动或任务**。
3. 顶点为**事件**。
4. 关键活动：关键路径上活动(边)为关键活动。
5. 关键路径：从原点到汇点**最大路径长度**的路径称为关键路径。
6. 事件(顶点)i：最早发生时间**v<sub>e</sub>(vi)**，最晚发生时间**v<sub>l</sub>(vi)**。
7. 活动(边)：最早开始时间e(ai)，最晚开始时间l(ai)。
8. 画图
   > ![image](https://note.youdao.com/yws/api/personal/file/7dca7a9a5f56b5ad970bc3cee5d0f0e0?method=download&shareKey=e9ee395d2b8338b61e6338c6eaa65240&inline=true)

9. 事件最迟发生时间**v<sub>l</sub>(vi)=v<sub>e</sub>(vi)**，或者取min。
10. 网中的关键路径不唯一，只有加快包含所有关键路径上的关键活动才能缩短工期，但也不能随意缩短，关键活动有可能变为非关键活动。
