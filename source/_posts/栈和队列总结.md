---
title: 栈和队列总结
date: 2021-01-07 18:02:12
tags: 栈 队列
categories: 数据结构与算法
---

1. 栈和队列是两种重要的线性结构。是操作受限的线性表。
2. 栈只能在一端进行插入和删除操作。
3. 栈的特点：后进先出LIFO。
4. 栈的两种存储方式：**顺序栈**，链栈。
5. 进栈操作：先赋值在加一(栈顶指针始终在栈顶元素的下一个位置上)。
6. 出栈操作：先减1，再取值。
7. 关于n个元素可能得到出栈不同排列个数：1/(1+n)Cn.2n
8. 队列在一端进行插入(队尾rear),在另一端进行删除(队头front)。
9. 队列特点：先进先出(FIFO)。
10. 队列的存储结构：顺序队和链队。
<!--more-->

### 结构体定义
```
    # 顺序栈
    typedef struct{
        int data[maxsize];
        int top;  // 总是指向栈顶
    }SqStack;
    
    #链栈 就是单链表
    typedef struct LNode{
        int data;
        struct LNode *next;
    }LNode;
    
    # 链式队列
    typedef struct QNode{  
        int data;
        struct QNode *next;
    }QNode;  // 结点定义
    
    typedef struct {
        QNode * front; // 队头指针
        QNode * rear;  // 队尾指针
    }LinkQueue;
    
    # 循环队列
    const int maxsize = 50;
    typedef struct {
        ElemType elem[maxsize];
        int front, rear;  // 对头队尾位置
    }SqQueue;
```

### 顺序栈
1. 栈空条件：s.top == 0; 
2. 栈满条件：s.top == maxsize;
3. 基本算法
   ```
   # 入栈操作
   bool push(SqStack &s, ElemType x){
       if (s.top == maxsize){
           return false;
       }
       // 先赋值在加1，top总是指向栈顶的下一个
       s.data[s.top]=x;
       s.top++;
       return true;
   }
   
   # 出栈操作
   bool pop(SqStack &s, ElemType &x){
       if (s.top == 0){
           retun false;
       }
       // 先减1，再取值
       s.top--;
       x = s.data[s.top];
       return true;
   }
   #取栈顶元素
   s.data[s.top-1]
   ```
### 共享栈
1. 将两个栈的栈低分别设置在共享空间的两端，两个栈顶向共享空间中间延伸。
    > ![image](https://note.youdao.com/yws/api/personal/file/93b0cba22276540cebb22af88f9299f7?method=download&shareKey=ebc4ccc79f680ceef6cf23eaaa6d9a8a&inline=true)

### 链栈(不带头结点)
1. 栈空条件：S == NULL。
2. 链栈的所有操作都是在表头进行。如图
   > ![image](https://note.youdao.com/yws/api/personal/file/b34a9779bf502677092d371814883796?method=download&shareKey=d9ab7dd5af824e88151265095e6ef887&inline=true)

3. 基本算法
   ```cpp
   # 入栈
   bool push(LinkStack &s, ElemType x){
       p = (LNode *)malloc(sizeof(LNode));
       p->data = x;
       p->next = s;
       s = p
       return true;
   }
   
   # 出栈
   bool pop(LinkStack &l, ElemType  &x){
       if (s == NULL){
           return false;
       }
       x = l->data;
       p = s;
       s = s->next;
       free(p);
       return true;
   }
   ```

### 链队列(带头节点)
实质是同时带**有队头指针**和**队尾指针**的单链表。如图:

> ![image](https://note.youdao.com/yws/api/personal/file/10a675fb56ff47ca8c76551aafb58963?method=download&shareKey=972836952063323eccd8d5bdeb7ef3e4&inline=true)

1. 队列为空条件：Q.front == Q.rear。// 头指针和尾指针都指向头结点
2. Q.front总是指向头结点，Q.rear总是指向最后一个结点。
3. 注：如果队列只有一个元素时，队头也是队尾，删除队头元素也要修改队尾指针(同时指向头节点)(删除操作时，可能头，尾指针都要修改)。
4. 基本算法： 

   1)入队列
   ```cpp
   # 入队列
   bool Enqueue(LinkQueue &Q, EmemType x){
       p = (LNode *)malloc(sizeof(LNode));
       p->data = x;
       p->next = NULL;
       Q.rear->next = p;
       Q.rear = p;
       return true;
   }
   
   ```
   > ![image](https://note.youdao.com/yws/api/personal/file/83c2e8ff23c008919a063734bd540c83?method=download&shareKey=84fac5e9e0c38b0a0ea76e6f783567b7&inline=true)

   2)出队列

   ```
   # 出队列
   bool DequeuQueue(LinkQueue &Q,ElemType &x){
       if (Q.front == Q.rear){ // 空栈
           return false;
       }
       p = Q.front->next;
       Q.front->next = p->next;
       x = p->data;
       if(Q.rear == p){
           Q.rear = Q.front;
       }
       free(p);
       return true;
   }
   ```
   > ![image](https://note.youdao.com/yws/api/personal/file/e216a0013d49f85146794298f9dd2922?method=download&shareKey=6d02352baa0239e28314dad821c578da&inline=true)

#### 循环队列
1. 区分队空队满两种方式：通常少用一个元素来区分队空和对列满；也可以加tag作为一标志。
2. 约定front指向队头元素，rear指向队尾元素的下一个位置。
3. 当少用一元素时
   - 队列空条件：Q.rear == Q.front
   - 队列满的条件：(Q.rear+1) % MAXSIZE == Q.front
   - 队列中元素的个数：(Q.rear -Q.front+Maxsize) % Maxsize
4. 当加标志时
   - 队列空和满时条件都为Q.front == Q.rear 再用tag标志区分。
   - 队列空时：Q.front == Q.rear && Q.tag == 0    // 在删除最后一个元素同时将tag置为0，则为空
   - 队列满时：Q.front == Q.rear && Q.tag == 1
5. 基本算法
   ```
   # 1. 少一个元素空间
   # 入队列
   bool Enqueue(SqQueue &Q, DataType x){
       if((Q.rear +1)%maxsize==Q.front){
           return false;
       }
       Q.elem[e.rear] = x;
       Q.rear = (Q.rear + 1) %maxsize;
       return true;
   }
   
   # 出队
   x = Q.elem[Q.front];
   Q.front = (Q.front +1)%maxsize;
   
   # 2. 使用tag标记
   # 初始化
   void init(SqQueue &Q){
       Q.front = Q.rear = 0;
       Q.tag = 0;
   }
   # 入队
   bool Enqueue(SqQueue &Q){
       if(Q.front == Q.rear && Q.tag == 1){
           return false;
       }
       Q.elem[Q.rear] = x;
       Q.rear = (Q.rear+1) %maxsize;
       if (Q.tag == 0)
           Q.tag = 1; 
       return true;
   }
   
   #出队
   bool DeQueue(SqQueue &Q, ElemType &x){
       if (Q.front == Q.rear && Q.tag == 0){  // 上一个操作是出队tag为0
           return false;
       }
       x = Q.elem[Q.front];
       Q.front = (Q.front +1)%maxsize;
       if (Q.front == Q.rear)  // 最后一个元素出队，front移动一位置到rear，正好两个指针相等
           Q.tag = 0;
       return true;
   }
   ```
6. 注：
   - 当前循环队列元素个数：`(rear - front + maxsize) % maxsize`
   - 当前循环队列剩余空间个数：`(front - rear +maxsize) % maxsize`

### 栈和队列应用
1. 表达式求值(前缀，中缀，后缀转换)
   ```
   例如： 表达式为(中缀)： [(A+B)*c] -(E-F)
      中缀转前缀表达式计算(先乘除，后加减，先括号内，后括号外)：
         +AB  -EF
         *+ABC  -EF
         -*+ABC-EF
      中缀转后缀：
         AB+     EF-
         AB+C*   EF-
         AB+C*EF--
   ```
   计算：
   > ![image](https://note.youdao.com/yws/api/personal/file/8746b9ecabe7e8e387d01240a96b179c?method=download&shareKey=abf37562e64f115a353e31d44c122da7&inline=true)
   

2. 括号匹配
   ```
   # 检查输入的表达式括号是否匹配
   bool matchBrackets(){
       const int Maxsize = 1024;  // 栈最大容量
       char s[maxsize];
       int top=0;  //栈顶
       ch = getchar();
       while(ch!=EOF){
           switch(ch){
               case '(','[','{':
                  s[top++] = ch; // 先赋值在加一
                  break;
               case ')':
                  if(top == 0 || s[--top] != '('))
                    return false;
               case ']':
                  if (top == 0 || s[--top] != '[')
                     return false;
                case '}':
                   if (top == 0|| s[--top] != '{')
                     return false;
           }
        ch = getchar();
       }
       if (top == 0)return true;
       else return false;
   }
   ```