---
title: 串总结
date: 2021-01-07 18:03:38
tags: 串 KMP算法
categories: 数据结构与算法
---

1. 串是逻辑结构，是限定元素为字符的线性表，用单引号括起来的字符序列是串的值。
2. 空串：零个字符的串，长度为0。
3. 空格串：由空格组成的串。
4. 子串：串中的任意**连续**的**子序列**。
5. 子串在主串中位置：子串中第一个字符在主串中位置(从1开始)。
6. 主串：包含子串的串。
7. 串相等：长度相等，对应字符相等。
8. 模式匹配是串的一种重要操作。(模式匹配就是找子串的位置)
9. 串的存储结构：①定长顺序串;②堆分配存储;③块链存储
10. 基本操作：
    ```
      assign(s,t)  // 将t赋值给s
      create(s,cs)  // 讲cs字符创建为字符串
      Equal(s,t)   // 判断s与t是否相等
      Length(s)    // 求s的长度
      Concat(s,t)  // 串连接，返回连接后新串。例如：concat("ab", "cd") = "abcd"
      Substr(s,pos,len)  // 从pos位置开始取len长度的子串。pos从1开始取，且包含pos位置
      Index(s,t)  // 求子串t在中位置，查找失败时候返回0。例如Index("abc","ab")=1
      replace(s,t,v)  // 将s中的t字符串用v替代。例如replace("abc","ab", "d")="dc"
      subcompare(s, t)  // 比较字符串大小。若s＞t，返回值＞0;s小于t时，返回值小于0;s=t时，返回值=0
    ```
11. 模式匹配算法
- 简单模式匹配
    ```cpp
    # 简单模式匹配
    int index(String s, String t){
        i = 1; j = 1;  // 字符串从数组下标1开始存储
        while(i<s[0] && j <= t[0]){  // 其中下标为0存储字符串的长度
            if(s[i] == t[j]){
                i++;
                j++;
            }
            else{
                i = i -j +2;  // 例如abdc与abc模式匹配，当i =3,j =3时，匹配失败，i回退到b的位置即3-3+2是b的下标
                j = 1;
            }
        }
        if(j > T[0])return i - T[0];
        else return 0;
    }
    ```
- kmp算法
    ```cpp
    # kmp算法手算

    前缀：例如'ababa'的前缀(除去最后一个字符) ：{a,ab,aba,abab}
    后缀：例如上式的后缀(除去第一个字符)：{a,ba,aba,baba}
    
    例如：求模式串T="abababcabc"的next数组值。
    步骤：
    1) 找除去第j位的前面几位的前缀和后缀。例如当j为3时对应字符为a，找ab的前缀和后缀最大相同长度
    2) 找最长的前缀和后缀相等。
    3) 将最长相等数+1。
    本题：
    ① 第一位默认为0。(j等于1时)
    ② 第二位为默认为0+1为1
    ③ 第三位为ab的最大前缀和后缀中相同，前缀为{a}，后缀为{b}即最大相同为0，则next值为0+1为1
    ④ 第四位找aba的最大前缀和后缀相同，前缀为{a,ab},后缀为{a, ba}即最大相同长度为1，则next值为1+1=2
    ⑤ 全部结果0112345123
    
    
    时间复杂度为O(m+n)  //模式串m，正文串n
    ```
- kmp算法改进
    ```cpp
    # kmp算法改进
    例如：已知模式串为T="abababcabc",则nextva函数值。
    
    步骤：
    1) 写出next数组
    2) 写nextval数组，当第一位时，对应的值为0，即nextval[1] = 0
    3) 当j＞1时，若T[j] ≠ T[next[j]]时，nextval[j] = next[j]；若T[j] = T[next[j]]时，nextval[j] = nextval[next[j]]
    
    本题：
    第一位默认0；
    第二位比较T[2]内容为b与T[next[2]]即T[1]内容为a，则不想等则nextval[2]=next[2]；
    第三位比较T[3]内容为a与T[next[3]]即T[1]内容为a，此时相等，nextval为nextval[next[3]]即为0；
    第四位比较T[4]与T[next[4]]即T[2]，相等，此时nextval为nextval[next[4]]=1；
    第五位比较T[5]与T[next[5]]，此时相等，nextval为nextval[next[5]]即为0；
    
    最后可得0101015013
    ```
- 求nextval的值
  > ![image](https://note.youdao.com/yws/api/personal/file/459e8acaa3f757f222d47f642f2ab031?method=download&shareKey=9e7463821d6f6ecaeddd5632c9fec614&inline=true)
